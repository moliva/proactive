<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="XML_Descriptors"><info><title>XML Deployment Descriptors</title></info>


  <indexterm>
    <primary>Descriptors</primary>

    <secondary>definition</secondary>
  </indexterm>

  <section xml:id="Descriptor_html_objectives"><info><title xml:id="Objectives_1">Objectives</title></info>

	<para>
		The main goal of using deployment descriptors is to remove all the deployment-related parameters from the source.
		Thus, a same source code can be used to deployed an application on different infrastructures.
	<newline/>
		Parameters tied to the deployment of an application should be
	totally described in a xml deployment descriptor. Hence within the source
	code, there are no longer any references to:
	</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Machine names</emphasis></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Creation Protocols</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>local</para>
            </listitem>

            <listitem>
              <para>ssh, gsissh, rsh, rlogin</para>
            </listitem>

            <listitem>
              <para>lsf, pbs, sun grid engine, oar, prun</para>
            </listitem>

            <listitem>
              <indexterm>
                <primary>Globus</primary>

                <secondary>XML Descriptor</secondary>
              </indexterm>

              <para>globus(GT2, GT3 and GT4), arc
              (nordugrid)</para>
            </listitem>
          </itemizedlist></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Registry/Lookup and Communications
        Protocols</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>rmi</para>
            </listitem>

            <listitem>
              <para>http</para>
            </listitem>

            <listitem>
              <para>rmissh</para>
            </listitem>

            <listitem>
              <para>ibis</para>
            </listitem>

            <listitem>
              <para>soap</para>
            </listitem>
          </itemizedlist></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Files Transfers</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>scp, rcp</para>
            </listitem>

            <listitem>
              <para>arc (nordugrid)</para>
            </listitem>

            <listitem>
              <para>other protocols like globus soon</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>

    <para>A ProActive application can be deployed on different hosts, with
    different protocols <emphasis role="bold">without</emphasis> changing the
    source code</para>
  </section>

  <section xml:id="Descriptor_Principles"><info><title xml:id="Principles_1">Principles</title></info>


    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Within a ProActive program, active objects
        are created on Nodes as usual.</emphasis></para>

		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/XMLDescriptor_1.snip"/></textobject></programlisting>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Nodes can be obtained from VirtualNodes
        (VN) declared and defined in a ProActiveDescriptor</emphasis></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Nodes are actual
        entities:</emphasis></para>

        <para>
			<itemizedlist>
		<listitem>
					<para>running into a JVM, on a host</para>
		</listitem>
				<listitem>
					<para>they are the results of mapping VN --&gt; JVMs</para>
				</listitem>
			</itemizedlist>
			But it is the <emphasis role="italics">VirtualNodes which are actually used in program source</emphasis>.
		</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">After activation, the names of Nodes mapped
        to a VirtualNode are defined as the VirtualNode name concatenated to a random
        number.</emphasis></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">VNs have the following
        characteristics:</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>a VN is uniquely identified with a String ID</para>
            </listitem>

            <listitem>
              <para>a VN is defined in a ProActiveDescriptor</para>
            </listitem>

            <listitem>
              <para>a VN has an object representation in a program after
              activation</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">A ProActiveDescriptor file specifies:</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>the mapping between VNs and JVMs</para>
            </listitem>

            <listitem>
              <para>the way to create, acquire JVMs using processes defined in
              the lower infrastructure part</para>
            </listitem>

            <listitem>
              <para>local, remote processes or combination of both to create
              remote jvms.</para>

              <para>For instance defining an <emphasis role="bold">sshProcess</emphasis> that itself references a local
              <emphasis role="bold">jvmProcess</emphasis>. At execution, the
              ssh process will launch a jvm on the remote machine specified in
              hostname attribute of <emphasis role="bold">sshProcess</emphasis> definition.</para>
            </listitem>

            <listitem>
              <para>files transfers</para>
            </listitem>

            <listitem>
              <para>fault tolerance, security</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Example:</emphasis></para>

		<programlisting language="xml"><textobject><textdata fileref="automatic_snippets/XMLDescriptor_2.snip"/></textobject></programlisting>

		<para>This example shows a
        VirtualNode called <emphasis role="bold">VN1</emphasis>, which
        is mapped to a JVM called <emphasis role="bold">jvm</emphasis>.</para>

        <para>This <emphasis role="bold">jvm</emphasis> will be created using
        the process called <emphasis role="bold">jvmProcess</emphasis> which
        is defined in the infrastructure part. This part will be discussed
        later on. But you can already notice that there are two parts in a descriptor file: an
        abstract one containing VirtualNode definitions and deployment
        information and a more concrete one containing concrete
        infrastructure information where all processes are
        defined.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Typical example of a program
        code:</emphasis></para>

		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/XMLDescriptor_3.snip"/></textobject></programlisting>
      </listitem>
    </itemizedlist>

    <para>
		<literal>org.objectweb.proactive.core.descriptor.data.ProActiveDescriptor</literal> and
		<literal>org.objectweb.proactive.core.descriptor.data.VirtualNode</literal> provides you with a set of methods
		to manipulate VirtualNodes. Please refer to the javadoc to learn more.</para>
  </section>

  <section xml:id="Descriptor_html_vn"><info><title xml:id="DifferenttypesofVirtualNodes_1">Different types of VirtualNodes</title></info>


    <section xml:id="VirtualNodesDefinition_1"><info><title>VirtualNodes Definition</title></info>


      <para><itemizedlist>
          <listitem>
            <para>Mapping one to one: 1 VN --&gt; 1 JVM</para>

            <programlisting language="xml">&lt;virtualNodesDefinition&gt;
	&lt;virtualNode name='Dispatcher'/&gt;
&lt;/virtualNodesDefinition&gt;
&lt;deployment&gt;
	&lt;mapping&gt;
		&lt;map virtualNode='Dispatcher'&gt;
			&lt;jvmSet&gt;
				&lt;vmName value='Jvm0'/&gt;
			&lt;/jvmSet&gt;
		&lt;/map&gt;
	&lt;/mapping&gt;
&lt;/deployment&gt;</programlisting>

			<para>Another possibility for the one to one
            mapping is to map 1 VN to the jvm running the program. In that
            case the lookup protocol can be specified but is optional (default
            value is the property <emphasis role="bold">proactive.communication.protocol</emphasis>) as it is
            shown in the following:</para>

            <programlisting language="xml">&lt;virtualNodesDefinition&gt;
	&lt;virtualNode name='Dispatcher'/&gt;
&lt;/virtualNodesDefinition&gt;
&lt;deployment&gt;
	&lt;mapping&gt;
		&lt;map virtualNode='Dispatcher'&gt;
			&lt;jvmSet&gt;
				&lt;currentJVM protocol='rmi'/&gt;
				&lt;!-- or &lt;currentJVM/&gt; --&gt;
			&lt;/jvmSet&gt;
		&lt;/map&gt;
	&lt;/mapping&gt;
&lt;/deployment&gt;</programlisting>

            <para>Since it is the current JVM, it does not have to be redefined
            later on in the descriptor. This will be shown in a complete
            example.</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>Mapping one to n: 1 VN --&gt; N JVMs</para>

            <programlisting language="xml">&lt;virtualNodesDefinition&gt;
	&lt;virtualNode name='Renderer' property='multiple'/&gt;
&lt;/virtualNodesDefinition&gt;
&lt;deployment&gt;
	&lt;mapping&gt;
		&lt;map virtualNode='Renderer'&gt;
			&lt;jvmSet&gt;
				&lt;currentJVM/&gt;
				&lt;vmName value='Jvm1'/&gt;
				&lt;vmName value='Jvm2'/&gt;
				&lt;vmName value='Jvm3'/&gt;
				&lt;vmName value='Jvm4'/&gt;
			&lt;/jvmSet&gt;
		&lt;/map&gt;
	&lt;/mapping&gt;
&lt;/deployment&gt;</programlisting>

			<para>Note that the <emphasis role="bold">property</emphasis> attribute is set to <emphasis role="bold">multiple</emphasis> since you want to map 1 VN to
            multiple JVMs. Then a set of JVMs is defined for the
            VirtualNode <emphasis role="bold">Renderer</emphasis>.
			<newline/>
			Four values are possible for this <emphasis role="bold">property</emphasis>
            attribute:
			<itemizedlist>
				<listitem>
					<para><emphasis role="bold">unique</emphasis> - one to one mapping</para>
				</listitem>
				<listitem>
					<para><emphasis role="bold">unique_singleAO</emphasis> - one to one mapping and
					only one active object deployed on the corresponding node</para>
				</listitem>
				<listitem>
					<para><emphasis role="bold">multiple</emphasis> - one to N mapping</para>
				</listitem>
				<listitem>
					<para><emphasis role="bold">multiple_cyclic</emphasis> - one to N mapping
			in a cyclic manner.</para>
				</listitem>
			</itemizedlist>

			This property is not mandatory but an
            exception can be thrown in case of incompatibility. For instance, an
			exception can be thrown if this
            property is set to unique and more than one jvm is defined in the
            jvmSet tag. In case of property set to <emphasis role="bold">unique_singleAO</emphasis>, the <emphasis role="bold">getUniqueAO()</emphasis> method of the
            <literal>org.objectweb.proactive.core.descriptor.data.VirtualNode</literal> class
            returns the unique AO created.</para>

			<newline/>
            <para>Three other attributes <emphasis role="bold">timeout,
            waitForTimeout, minNodeNumber</emphasis> can be set when defining
            a virtualNode</para>

            <programlisting language="xml">&lt;virtualNodesDefinition&gt;
	&lt;virtualNode name='Dispatcher' timeout='200' waitForTimeout='true'/&gt;
	&lt;virtualNode name='Renderer' timeout='200' minNodeNumber='3'/&gt;
&lt;/virtualNodesDefinition&gt;</programlisting>

            <para>Depending on the value of <emphasis role="bold">waitForTimeout</emphasis>, the <emphasis role="bold">timeout</emphasis> attribute
            has two different meanings.
			If the <emphasis role="bold">waitForTimeout</emphasis> attribute, which is a boolean, is
            set to <emphasis role="bold">true</emphasis>, then you will have to
            wait exactly <emphasis role="bold">timeout</emphasis> milliseconds before accessing Nodes.
			If <emphasis role="bold">waitForTimeout</emphasis> is set to
            <emphasis role="bold">false</emphasis>, then <emphasis role="bold">timeout</emphasis> represents the
            maximum amount of time to wait, i.e. no more nodes will be created
            once this timeout over.
            Default value for <emphasis role="bold">waitForTimeout</emphasis>
            attribute is <emphasis role="bold">false</emphasis>.
			<newline />
			The <emphasis role="bold">minNodeNumber</emphasis> attribute defines the minimum
            number of nodes to be created. If not
            defined, access to the nodes will occur once the timeout expires,
            or the number of nodes expected are effectively created. Setting
            this attribute allows to redefine the number of nodes expected, we
            define it as the number of nodes needed for the VirtualNode to be
            suitable for the application. In the example above, once
            <emphasis role="bold">3</emphasis> nodes are created and mapped to
            the VirtualNode <emphasis role="bold">Renderer</emphasis>, this
            VirtualNode starts to give access to its nodes. Those options are
            very useful when there is no idea about how many nodes will be
            mapped on the VirtualNode (which is often unusual). All those
            attributes are optional.</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>Mapping n to one: N VN --&gt; 1 JVMs</para>

            <programlisting language="xml">&lt;virtualNodesDefinition&gt;
	&lt;virtualNode name='Dispatcher' property='unique_singleAO'/&gt;
	&lt;virtualNode name='Renderer' property='multiple'/&gt;
&lt;/virtualNodesDefinition&gt;
&lt;deployment&gt;
	&lt;mapping&gt;
		&lt;map virtualNode='Dispatcher'&gt;
			&lt;jvmSet&gt;
				&lt;vmName value='Jvm1'/&gt;
			&lt;/jvmSet&gt;
		&lt;/map&gt;
		&lt;map virtualNode='Renderer'&gt;
			&lt;jvmSet&gt;
				&lt;vmName value='Jvm1'/&gt;
				&lt;vmName value='Jvm2'/&gt;
				&lt;vmName value='Jvm3'/&gt;
				&lt;vmName value='Jvm4'/&gt;
			&lt;/jvmSet&gt;
		&lt;/map&gt;
	&lt;/mapping&gt;
&lt;/deployment&gt;</programlisting>
			<para>In this example both VirtualNodes <emphasis role="bold">Dispatcher</emphasis> and <emphasis role="bold">Renderer</emphasis> have a mapping with <emphasis role="bold">Jvm1</emphasis>, it means that at deployment time,
            both VirtualNodes will get nodes created in the same JVM. Here is
            the notion of <emphasis role="bold">co-allocation</emphasis> in a
            JVM.</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>VirtualNode registration</para>

            <para>Descriptors provide the ability to register a VirtualNode in
            a registry such as RMIRegistry, HTTP registry, IBIS/RMI
            Registry Service. Hence this VirtualNode will be accessible from
            another application as it is described in <xref linkend="VirtualNodesAcquisition_1"/>. The
            protocol (registry) to use can be specified in the descriptor. If
            not specified, the VirtualNode will register using the protocol
            specified in the <emphasis role="bold">proactive.communication.protocol</emphasis>
            property which is <emphasis role="bold">rmi</emphasis> by default.</para>

            <programlisting language="xml">&lt;virtualNodesDefinition&gt;
	&lt;virtualNode name='Dispatcher' property='unique_singleAO'/&gt;
&lt;virtualNodesDefinition/&gt;
&lt;deployment&gt;
	&lt;register virtualNode='Dispatcher' protocol='rmi'/&gt;
	&lt;!-- or &lt;register virtualNode='Dispatcher'/&gt; --&gt;
	&lt;!-- Using this syntax, registers the VirtualNode with the protocol
			specified in proactive.communication.protocol property --&gt;
	&lt;mapping&gt;
		&lt;map virtualNode='Dispatcher'&gt;
			&lt;jvmSet&gt;
				&lt;vmName value='Jvm0'/&gt;
			&lt;/jvmSet&gt;
		&lt;/map&gt;
	&lt;/mapping&gt;
&lt;/deployment&gt;</programlisting>

            <para>The <emphasis role="bold">register</emphasis> tag allows to
            register the VirtualNode <emphasis role="bold">Dispatcher</emphasis> when activated, on the local
            machine in a RMIRegistry. As said before this VirtualNode will
            be accessible by another application using the lookup tag (see
            below) or using the <literal>lookupVirtualNode</literal> method of
            the <literal>PADeployment</literal> class.</para>
          </listitem>
        </itemizedlist>
	  </para>
    </section>

    <section xml:id="VirtualNodesAcquisition_1"><info><title>VirtualNodes Acquisition</title></info>

      <indexterm>
        <primary>Acquisition</primary>
        <secondary>VirtualNode</secondary>
      </indexterm>

      <para>Descriptors provide the ability to acquire a VirtualNode already
      deployed by another application. Such VirtualNodes are defined in
      <emphasis role="bold">VirtualNodes Acquisition</emphasis> tag as it is
      done for <emphasis role="bold">VirtualNodesDefinition</emphasis> except
      that no property and no mapping with jvms are defined since such VNs are
      already deployed. In the deployment part, the lookup tag gives
      information on where and how to acquire the VirtualNode. Lookup will be
      performed when activating the VirtualNode.</para>

      <programlisting language="xml">&lt;virtualNodesAcquisition&gt;
	&lt;virtualNode name='Dispatcher'/&gt;
&lt;/virtualNodesAcquisition&gt;
..........
&lt;deployment&gt;
	..........
	&lt;lookup virtualNode='Dispatcher' host='machine_name' protocol='rmi' port='2020'/&gt;
&lt;/deployment&gt;</programlisting>

      <para>As mentioned in the previous section, in order to acquire
      VirtualNode <emphasis role="bold">Dispatcher</emphasis>, it must have
      previously been registered on the specified host by another application.
      Sometimes, the host where to perform the lookup will only be known at
      runtime. In that case, it is specified in the descriptor with '*' for the
      host attribute.</para>

      <programlisting language="xml">&lt;lookup virtualNode='Dispatcher' host='*' protocol='rmi'/&gt;</programlisting>

      <para>Then when the host name is available, ProActive provides the method
      <emphasis role="bold">setRuntimeInformations</emphasis> in the
      <literal>org.objectweb.proactive.core.descriptor.data.VirtualNode</literal> class to update the
      value and to perform the lookup. Typical example of code:</para>

      <programlisting language="java">// Returns a ProActiveDescriptor object from the xml file
ProActiveDescriptor pad = PADeployment.getProactiveDescriptor(String xmlFileLocation);

// Activates all VirtualNodes (definition and acquisition)
pad.activateMappings();

// Gets the Dispatcher virtual node
VirtualNode vnDispatcher = pad.getVirtualNode('Dispatcher');

// Sets the host to lookup by setting the LOOKUP_HOST property
vnDispatcher.setRuntimeInformations('LOOKUP_HOST','machine_name);
</programlisting>

      <para>To summarize, all VirtualNodes are activated when calling the activate
      method except if '*' is set for a VirtualNode to be acquired. In that
      case, the lookup will be performed when giving host information.</para>

      <para>Registration and lookup can be performed automatically when using
      tags in the descriptor as well as programmatically using static methods
      provided by the <literal>org.objectweb.Proactive</literal> class:</para>

      <programlisting language="java">PADeployment.registerVirtualNode(VirtualNode virtualNode, String registrationProtocol, boolean replacePreviousBinding);</programlisting>

      <programlisting language="java">PADeployment.lookupVirtualNode(String url, String protocol);</programlisting>

      <programlisting language="java">PADeployment.unregisterVirtualNode(VirtualNode virtualNode);</programlisting>
    </section>
  </section>

  <section xml:id="Descriptor_html_jvms"><info><title xml:id="DifferenttypesofJVMs_1">Different types of JVMs</title></info>


    <section xml:id="Creation_1"><info><title>Creation</title></info>


      <para>
		<itemizedlist>
          <listitem>
            <para>1 JVM --&gt; 1 Node</para>

            <programlisting language="xml">...........................
&lt;jvm name='jvm1'&gt;
	&lt;creation&gt;
		&lt;processReference refid='jvmProcess'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...........................
</programlisting>

			<para>In this example, <literal>jvm1</literal> will be created using the process
            called <emphasis role="bold">jvmProcess</emphasis> (as discussed
            later on, this process represents a java process and can be seen as
            the <literal>java ProActiveClassname</literal> command)</para>
          </listitem>
		</itemizedlist>

		<itemizedlist>
          <listitem>
            <para>1 JVM --&gt; N Nodes on a single JVM</para>

            <para><programlisting language="xml">...........................
&lt;jvm name='jvm1' askedNodes='3'&gt;
	&lt;creation&gt;
		&lt;processReference refid='jvmProcess'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...........................
</programlisting></para>
          </listitem>
		</itemizedlist>

		<itemizedlist>
          <listitem>
            <para>1 JVM --&gt; N Nodes on N JVMs</para>
            <para>This is the case when the referenced process is a cluster
            process (LSF, PBS, GLOBUS, ...) or a process list (see <xref linkend="Descriptor_html_processlist"/>)</para>
          </listitem>
		</itemizedlist>

	  </para>
    </section>

    <section xml:id="Acquisition_1"><info><title>Acquisition</title></info>


      <indexterm>
        <primary>Acquisition</primary>

        <secondary>JVM</secondary>
      </indexterm>

      <para>Descriptors give the ability to acquire JVMs instead of creating
      them. To do so, it must be specified in the <emphasis role="bold">acquisition</emphasis> tag which service to use in oder to
      acquire the JVMs. Services will be described below, in the
      infrastructure part. At this point one service is provided: the <emphasis role="bold">RMIRegistryLookup</emphasis> service.</para>

      <programlisting language="xml">&lt;jvm name='jvm1'&gt;
	&lt;acquisition&gt;
		&lt;serviceReference refid='lookup'/&gt;
	&lt;/acquisition&gt;
&lt;/jvm&gt;
...........................</programlisting>

      <para>In this example, <emphasis role="bold">Jvm1</emphasis> will be
      acquired using the service called <emphasis role="bold">lookup</emphasis> (as discussed later on, this service represents
      a way to acquire a JVM). Note that the name <emphasis role="bold">lookup</emphasis> is totally arbitrary on condition
      that a service with the id <emphasis role="bold">lookup</emphasis> is
      defined in the infrastructure part.</para>
    </section>
  </section>

  <section xml:id="Descriptor_html_validation"><info><title xml:id="ValidationagainstXMLSchema_1">Validation against XML Schema</title></info>


    <para>To avoid mistake when building XML descriptors, ProActive provides
    an XML Schema called <emphasis role="bold">DescriptorSchema.xsd</emphasis>. To validate your file
    against this schema, the following line must be put at the top of the xml
    document as it is done for all ProActive examples:</para>

	<programlisting language="xml"><textobject><textdata fileref="automatic_snippets/XMLDescriptor_4.snip"/></textobject></programlisting>

    <para>Note that this schema is available in the ProActive distribution
    package in the <literal>PROACTIVE_HOME/src/Core/org/objectweb/proactive/core/descriptor/xml/schemas/deployment/3.3/deployment.xsd</literal> file.
	Using descriptors related
    methods (Proactive.getProactiveDescriptor(file)) triggers automatic and
    transparent validation of the file using <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://xml.apache.org/xerces2-j/index.html">Xerces2_4_0</link> if
    the ProActive property <emphasis role="bold">schema.validation</emphasis>
    is set to <emphasis role="bold">enable</emphasis> (see <xref linkend="Configuration"/> for more details). If a problem occurs during
    the validation, an error message is displayed. Otherwise, if the
    validation is successful, no message appears. An XML validation tool such
    as xmllint command on Unix or XMLSPY5.0 on Windows can also be used to validate XML descriptors.</para>
  </section>

  <section xml:id="Completedescriptionandexamples_1"><info><title>Complete description and examples</title></info>


    <para>The following XML files was used for the C3D application before being replaced by GCM Deployment descriptors.
	The first file is read when launching the C3DDispatcher. The second one is
    read every time a C3DUser is added. Both files contain many features
    described earlier in this document.</para>

    <example xml:id="C3D_Dispatcher_Renderxml_1"><info><title>C3D_Dispatcher_Render.xml</title></info>

		<para><programlisting language="xml">&lt;ProActiveDescriptor
	xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
	xsi:noNamespaceSchemaLocation='DescriptorSchema.xsd'&gt;
	&lt;componentDefinition&gt;
		&lt;virtualNodesDefinition&gt;
			&lt;virtualNode name='Dispatcher' property='unique_singleAO'/&gt;
			&lt;virtualNode name='Renderer' property='multiple'/&gt;
		&lt;/virtualNodesDefinition&gt;
	&lt;/componentDefinition&gt;
	&lt;deployment&gt;
		&lt;register virtualNode='Dispatcher'/&gt;
		&lt;mapping&gt;
			&lt;map virtualNode='Dispatcher'&gt;
				&lt;jvmSet&gt;
					&lt;currentJvm/&gt;
				&lt;/jvmSet&gt;
			&lt;/map&gt;
			&lt;map virtualNode='Renderer'&gt;
				&lt;jvmSet&gt;
					&lt;vmName value='Jvm1'/&gt;
					&lt;vmName value='Jvm2'/&gt;
					&lt;vmName value='Jvm3'/&gt;
					&lt;vmName value='Jvm4'/&gt;
				&lt;/jvmSet&gt;
			&lt;/map&gt;
		&lt;/mapping&gt;
		&lt;jvms&gt;
			&lt;jvm name='Jvm1'&gt;
				&lt;creation&gt;
					&lt;processReference refid='jvmProcess'/&gt;
				&lt;/creation&gt;
			&lt;/jvm&gt;
			&lt;jvm name='Jvm2'&gt;
				&lt;creation&gt;
					&lt;processReference refid='jvmProcess'/&gt;
				&lt;/creation&gt;
			&lt;/jvm&gt;
			&lt;jvm name='Jvm3'&gt;
				&lt;creation&gt;
					&lt;processReference refid='jvmProcess'/&gt;
				&lt;/creation&gt;
			&lt;/jvm&gt;
			&lt;jvm name='Jvm4'&gt;
				&lt;creation&gt;
					&lt;processReference refid='jvmProcess'/&gt;
				&lt;/creation&gt;
			&lt;/jvm&gt;
		&lt;/jvms&gt;
	&lt;/deployment&gt;
	&lt;infrastructure&gt;
		&lt;processes&gt;
			&lt;processDefinition id='jvmProcess'&gt;
				&lt;jvmProcess
					class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
			&lt;/processDefinition&gt;
		&lt;/processes&gt;
	&lt;/infrastructure&gt;
&lt;/ProActiveDescriptor&gt;</programlisting>
		</para>
    </example>
    <para>The abstract part containing VirtualNodes definition and
    deployment informations has already been explained. To summarize, two
    VirtualNodes are defined <emphasis role="bold">Dispatcher</emphasis> and
    <emphasis role="bold">Renderer</emphasis>. <emphasis role="bold">Dispatcher</emphasis> is mapped to the jvm running the <literal>main()</literal> method,
    and will be exported using the protocol specified in the <emphasis role="bold">proactive.communication.protocol</emphasis> property. This
    VirtualNode will be registered in a Registry (still using the protocol
    specified in <emphasis role="bold">proactive.communication.protocol</emphasis> property) when
    activated. As for <emphasis role="bold">Renderer</emphasis>, it is mapped to a set of
    JVMs called <emphasis role="bold">Jvm1</emphasis>, ..., <emphasis role="bold">Jvm4</emphasis>.</para>

    <example xml:id="C3D_Userxml_1"><info><title>C3D_User.xml</title></info>

      <para><programlisting language="xml">&lt;ProActiveDescriptor
	xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
	xsi:noNamespaceSchemaLocation='DescriptorSchema.xsd'&gt;
	&lt;componentDefinition&gt;
		&lt;virtualNodesDefinition&gt;
			&lt;virtualNode name='User'/&gt;
		&lt;/virtualNodesDefinition&gt;
		&lt;virtualNodesAcquisition&gt;
			&lt;virtualNode name='Dispatcher'/&gt;
		&lt;/virtualNodesAcquisition&gt;
	&lt;/componentDefinition&gt;
	&lt;deployment&gt;
		&lt;mapping&gt;
			&lt;map virtualNode='User'&gt;
				&lt;jvmSet&gt;
					&lt;currentJvm/&gt;
				&lt;/jvmSet&gt;
			&lt;/map&gt;
		&lt;/mapping&gt;
		&lt;lookup virtualNode='Dispatcher' host='*' protocol='rmi'/&gt;
	&lt;/deployment&gt;
	&lt;infrastructure&gt;
		&lt;processes&gt;
			&lt;processDefinition id='jvmProcess'&gt;
				&lt;jvmProcess
					class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
			&lt;/processDefinition&gt;
		&lt;/processes&gt;
	&lt;/infrastructure&gt;
&lt;/ProActiveDescriptor&gt;</programlisting></para>
   </example>
    <para>This file is read when adding a C3DUser. Two VirtualNodes are
    defined: <emphasis role="bold">User</emphasis> which is mapped to the jvm
    running the <literal>main()</literal> method, whose acquisition method is performed by looking up
    the RMIRegistry, and <emphasis role="bold">Dispatcher</emphasis> in the
    <emphasis role="bold">virtualNodesAcquisition</emphasis> part which will
    be the result of a lookup in the RMIRegistry of a host to be specified at
    runtime.</para>
  </section>

  <section xml:id="Descriptor_html_infrastructure"><info><title xml:id="DESCRIPTOR_Infrastructure_and_processes">Infrastructure and
    processes</title></info>


    <para>In the previous example, all defined JVMs are created using
    <emphasis role="bold">jvmProcess</emphasis> process. This process is
    totally defined in the <emphasis role="bold">infrastructure</emphasis>
    part. Of course the process name in the creation part must point to an
    existing defined process in the <emphasis role="bold">infrastructure</emphasis> part. For instance, if the name in
    the creation tag is <emphasis role="bold">localJVM</emphasis>, there must
    be a process defined in the <emphasis role="bold">infrastructure</emphasis> with the id <emphasis role="bold">localJVM</emphasis></para>

    <section xml:id="LocalJVMs_1"><info><title>Local JVMs</title></info>


      <indexterm>
        <primary>LocalJVM</primary>
      </indexterm>

      <para>In the previous example, the
      defined process <emphasis role="bold">jvmProcess</emphasis> will create
      local JVMs. The class attribute defines the class to instantiate in
      order to create the process. ProActive library provides a class to
      instantiate in order to create processes that will launch local JVMs:
      <literal>org.objectweb.proactive.core.process.JVMNodeProcess</literal></para>

      <programlisting language="xml">&lt;infrastructure&gt;
	&lt;processes&gt;
		&lt;processDefinition id='jvmProcess'&gt;
			&lt;jvmProcess class='org.objectweb.proactive.core.process.JVMNodeProcesss'&gt;
				&lt;classpath&gt;
					&lt;absolutePath value='/home/ProActive/classes'/&gt;
					&lt;absolutePath value='/home/ProActive/lib/bcel.jar'/&gt;
					&lt;absolutePath value='/home/ProActive/lib/asm.jar'/&gt;
					&lt;absolutePath value='/home/ProActive/lib/reggie.jar'/&gt;
				&lt;/classpath&gt;
				&lt;javaPath&gt;
					&lt;absolutePath value='/usr/local/jdk1.4.0/bin/java'/&gt;
				&lt;/javaPath&gt;
				&lt;policyFile&gt;
					&lt;absolutePath value='/home/ProActive/dist/proactive.java.policy'/&gt;
				&lt;/policyFile&gt;
				&lt;log4jpropertiesFile&gt;
					&lt;relativePath origin='user.home' value='ProActive/dist/proactive-log4j'/&gt;
				&lt;/log4jpropertiesFile&gt;
				&lt;ProActiveUserPropertiesFile&gt;
					&lt;absolutePath value='/home/config.xml'/&gt;
				&lt;/ProActiveUserPropertiesFile&gt;
				&lt;jvmParameters&gt;
					&lt;parameter
						value='-Djava.library.path=/home1/fabrice/workProActive/ProActive/lib'/&gt;
					&lt;parameter
						value='-Dsun.boot.library.path=/home1/fabrice/workProActive/ProActive/lib'/&gt;
					&lt;parameter value='-Xms512 -Xmx512'/&gt;
				&lt;/jvmParameters&gt;
			&lt;/jvmProcess&gt;
		&lt;/processDefinition&gt;
	&lt;/processes&gt;
&lt;/infrastructure&gt;
</programlisting>

      <indexterm>
        <primary>CLASSPATH</primary>
        <secondary>deployment descriptor</secondary>
      </indexterm>

      <para>As shown in the example above, <emphasis role="bold">ProActive</emphasis> provides the ability to define or
      change the <emphasis role="bold">classpath</emphasis> environment
      variable, the <emphasis role="bold">java path</emphasis>, the <emphasis role="bold">policy file path</emphasis>, the <emphasis role="bold">log4j
      properties file path</emphasis>, the <emphasis role="bold">ProActive
      properties file path</emphasis> (see <xref linkend="Configuration"/>
      for more details) and also to pass <emphasis role="bold">parameters</emphasis> to the JVM to be created.
	  </para>
	  <note>
		<para>
			Note that parameters to be passed here are related to the
			jvm in opposition to properties given in the configuration file (see
			<xref linkend="Configuration"/>), which is more focused on ProActive or
			application behaviour. In fact parameters given here will be part of the
			java command to create other jvms, whereas properties given in the
			config file will be loaded once the jvm is created.
		</para>
	  </note>

      <para>If not specified, there is a default value (except for the
      jvmParameters element) for each of these variables. In the first example
      of this section, only the <emphasis role="bold">Id</emphasis> of the
      process, and the <emphasis role="bold">class</emphasis> to instantiate
      are defined.
	  If for example the home directory of the remote machine where you want to create a JVM is
	  not the same as the one of your local machine, then
	  you might want to define or redefine variable such as
	  the <emphasis role="bold">classpath</emphasis> or <emphasis role="bold">java
      path</emphasis> or <emphasis role="bold">policyfile path</emphasis>.
      As shown in the example, <emphasis role="bold">paths</emphasis> to files
      can be either <emphasis role="bold">absolute</emphasis> or <emphasis role="bold">relative</emphasis>. If relative, an origin must be
      provided, it can be <emphasis role="bold">user.home</emphasis> or
      <emphasis role="bold">user.dir</emphasis> or <emphasis role="bold">user.classpath</emphasis> and it is resolved <emphasis role="bold">locally</emphasis>, i.e on the JVM reading the descriptor
      and not on the remote JVM that is going to be created.</para>

      <para>As mentionned in the configuration file (see <xref linkend="Configuration"/>), if the &lt;ProActiveUserPropertiesFile&gt;
      is not defined for remote JVMs, they will load a default one once
      created.</para>

      <para>Even if not shown in this example, a specific tag is provided for
      <literal>XbootClasspathi</literal> option under the form.</para>

      <programlisting language="xml">&lt;bootclasspath&gt;
	&lt;relativePath origin='user.home' value='/IOFAb/Ibis/'/&gt;
	&lt;relativePath origin='user.home' value='/IOFAb/classlibs/jdk'/&gt;
&lt;/bootclasspath&gt;
</programlisting>
    </section>

    <section xml:id="RemoteJVMs_1"><info><title>Remote JVMs</title></info>

      <para>With XML Deployment Descriptor, <emphasis role="bold">ProActive</emphasis> provides the ability to create remote
      Nodes (remote JVMs). You can specify in the descriptor if you want to
      access the remote host with <emphasis role="bold">rsh</emphasis>,
      <emphasis role="bold">ssh</emphasis>, <emphasis role="bold">rlogin</emphasis>, <emphasis role="bold">lsf</emphasis>,
      <emphasis role="bold">pbs</emphasis>, <emphasis role="bold">oar</emphasis>, <emphasis role="bold">prun</emphasis>,
      <emphasis role="bold">globus</emphasis>, <emphasis role="bold">arc
      (nordugrid)</emphasis>. How to
      use these protocols is explained in the following examples. Just remind
      that you can also combine these protocols.The principle of combination
      is fairly simple, you can imagine for instance that you will log on a
      remote cluster frontend with <emphasis role="bold">ssh</emphasis>, then
      use <emphasis role="bold">pbs</emphasis> to book nodes and to create
      <emphasis role="bold">JVMs</emphasis> on each. You will also notice that
      there is at least one combination for each remote protocol. Indeed each
      remote protocol <emphasis role="bold">must</emphasis> have a pointer
      either on another remote protocol or on a <emphasis role="bold">jvmProcess</emphasis> to create a jvm (discussed
      previously).</para>

      <para>You can find in the <literal>$PROACTIVE_HOME/descriptors/examples_legacy_descriptors/</literal> directory
      several examples of supported protocols and useful combinations.</para>

	  <note>
		  <para>For using the ProActive XML Deployment,
		  ProActive has to be installed on
		  the local host as well as on every machine you want to create
		  Nodes on.</para>
	  </note>

      <itemizedlist>
        <listitem>
          <para>RSH</para>

          <programlisting language="xml">...........................
&lt;jvm name='jvm1'&gt;
	&lt;creation&gt;
		&lt;processReference refid='rshProcess'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...........................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess
			class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='rshProcess'&gt;
		&lt;rshProcess
			class='org.objectweb.proactive.core.process.rsh.RSHProcess' hostname='sea.inria.fr'&gt;
			&lt;processReference refid='jvmProcess'/&gt;
		&lt;/rshProcess&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;</programlisting>
		<para>For <emphasis role="bold">jvm1</emphasis> the creation process
          is <emphasis role="bold">rshProcess</emphasis>
          which is defined in the <emphasis role="bold">infrastructure</emphasis> section. To define this
          process you have to give the class to instantiate to create the
          <emphasis role="bold">rsh</emphasis> process. <emphasis role="bold">ProActive</emphasis> provides
          <literal>org.objectweb.proactive.core.process.rsh.RSHProcess</literal>
          to create <emphasis role="bold">rsh</emphasis> process. You must
          give the remote host name to log on with rsh. You can define as well
          <literal>username='toto'</literal> if you plan to use rsh with
          <emphasis role="bold">-l option</emphasis>. As said before this
          <emphasis role="bold">rsh</emphasis> process <emphasis role="bold">must</emphasis> reference a local process, and in the
          example, it references the process defined with the id <emphasis role="bold">jvmProcess</emphasis>. It means that once logged on
          sea.inria.fr with rsh, a local JVM will be launched, ie a ProActive
          node will be created on sea.inria.fr thanks to the process defined
          by <emphasis role="bold">jvmProcess</emphasis>.</para>

		  <newline/>
          <para>Here is a complete RSH deployment example:</para>

          <programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/RSH_Example.xml"> </textdata></textobject></programlisting>

        </listitem>

        <listitem>
          <para>RLOGIN</para>

          <programlisting language="xml">...........................
&lt;jvm name='jvm1'&gt;
	&lt;creation&gt;
		&lt;processReference refid='rloginProcess'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...........................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess
			class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='rloginProcess'&gt;
		&lt;rloginProcess
			class='org.objectweb.proactive.core.process.rlogin.RLoginProcess'
			hostname='sea.inria.fr'&gt;
			&lt;processReference refid='jvmProcess'/&gt;
		&lt;/rloginProcess&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;</programlisting>
		<para>You can use <emphasis role="bold">rlogin</emphasis> in the same way
          that you would use <emphasis role="bold">rsh</emphasis></para>
        </listitem>

        <listitem>
          <para>SSH</para>

          <programlisting language="xml">...........................
&lt;jvm name='jvm1'&gt;
	&lt;creation&gt;
		&lt;processReference refid='sshProcess'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...........................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess
			class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='sshProcess'&gt;
		&lt;sshProcess
			class='org.objectweb.proactive.core.process.ssh.SSHProcess'
			hostname='sea.inria.fr'&gt;
			&lt;processReference refid='jvmProcess'/&gt;
		&lt;/sshProcess&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;</programlisting>
		 <para><emphasis role="bold">ProActive</emphasis> provides
          <literal>org.objectweb.proactive.core.process.ssh.SSHProcess</literal>
          to create <emphasis role="bold">ssh</emphasis> process.</para>

          <para>In order to use ssh to log on a remote host, you must perform
          some actions. First you need to copy your public key (located in
          identity.pub under ~/.ssh on your local machine) in the
          authorized_keys file (located under ~/.ssh) of the remote host. Then
          to avoid interactivity, you will have to launch on the local host
          the ssh-agent command: <emphasis role="bold">ssh-agent
          $SHELL</emphasis>. This command can be put in your .xsession file,
          in order to run it automatically when logging on your station. Then
          launching <emphasis role="bold">ssh-add</emphasis> command to add
          your identity, you will be asked to enter your
          <emphasis role="bold">passphrase</emphasis>, the one you
          provided when you have generated your ssh key pair.</para>

          <para>Note that if the generated key pair is not encrypted (no
          passphrase), you do not need to run neither the ssh-agent, nor the
          ssh-add command. Indeed it is sufficient when using non encrypted
          private key, to only copy the public key on the remote host (as
          mentionned above) in order to get logged automatically on the remote
          host.</para>

          <para>These steps must be performed <emphasis role="bold">before</emphasis> running any ProActive application
          using <emphasis role="bold">ssh</emphasis> protocol. If you are not
          familiar with ssh, see <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.openssh.org">openSSH</link></para>

          <para>The following is a complete SSH deployment example.</para>

          <programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/SSH_Example.xml"/></textobject></programlisting>
        </listitem>

        <listitem xml:id="Descriptor_html_processlist" xreflabel="Process list">
          <para>Process List</para>

          <para>ProActive provides a way to define a list of processes for
          <emphasis role="bold">RSH, SSH, RLOGIN</emphasis> protocols. Using
          <emphasis role="bold">processList</emphasis> or <emphasis role="bold">processListbyHost</emphasis> elements avoids having a
          long deployment file when many machines with similar names are going
          to be connected with protocols mentionned before. The first example
          below shows how to use <emphasis role="bold">processList</emphasis>
          tag and the second one how to use <emphasis role="bold">processListbyHost</emphasis>.</para>

          <programlisting language="xml">...........................
&lt;jvm name='jvm1'&gt;
	&lt;creation&gt;
		&lt;processReference refid='processlist'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...........................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess
			class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='processlist'&gt;
		&lt;processList
			class='org.objectweb.proactive.core.process.ssh.SSHProcessList'
			fixedName='node-' list='[0-100;2]^[10,20]'
			padding='3' domain='sophia.grid5000.fr'&gt;
			&lt;processReference refid='jvmProcess'/&gt;
		&lt;/processList&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;</programlisting>

          <para>When using <emphasis role="bold">processList tag</emphasis>,
          the <emphasis role="bold">class</emphasis> attribute can take 3
          values:</para>
		  <itemizedlist>
              <listitem>
                <para>org.objectweb.proactive.core.process.ssh.SSHProcessList</para>
                <programlisting language="java"><textobject><textdata fileref="automatic_snippets/sshprocesslist.snip"/></textobject></programlisting>

              </listitem>

              <listitem>
                <para>org.objectweb.proactive.core.process.rsh.RSHProcessList</para>
               <programlisting language="java"><textobject><textdata fileref="automatic_snippets/rshprocesslist.snip"/></textobject></programlisting>
              </listitem>

              <listitem>
                <para>org.objectweb.proactive.core.process.rlogin.RLoginProcessList</para>
               <programlisting language="java"><textobject><textdata fileref="automatic_snippets/rloginprocesslist.snip"/></textobject></programlisting>
              </listitem>
          </itemizedlist>
		  <para>The <emphasis role="bold">fixedName</emphasis> attribute
          is mandatory and represents the fixed part shared by all machine
          names.
		  <newline/>
		  The <emphasis role="bold">list</emphasis> attribute is also
          mandatory and can take several forms:
		  <itemizedlist>
			  <listitem><para><emphasis role="bold">[m-n]</emphasis> means from m to n with a step 1,</para></listitem>
			  <listitem><para><emphasis role="bold">[m-n;k]</emphasis> means from m to n with a step k (m, m+k, m+2k, ....),</para></listitem>
			  <listitem><para><emphasis role="bold">[m-n]^[x,y]</emphasis> means from m to n excluding x and y,</para></listitem>
			  <listitem><para><emphasis role="bold">[m-n]^[x,y-z]</emphasis> means from m to n
				  excluding x and values from y to z,</para></listitem>
			  <listitem><para><emphasis role="bold">[m-n;k]^[x,y]</emphasis> same as before except that the
				  step is k.</para></listitem>
		  </itemizedlist>
		  <newline/>
		  The <emphasis role="bold">padding</emphasis> attribute is
          optional (default is 1) and represents the number of digits to use for the node number.
		  For instance, the node 1 with a padding equal to 3 will be written 001.
		  <newline/>
		  Finally, the <emphasis role="bold">domain</emphasis> attribute is mandatory
          and represents the last part shared by all machine names. Thus, in
          the previous example, a jvm is going to be created using ssh on
          machines: node000.sophia.grid5000.fr,
          node002.sophia.grid5000.fr,..., node098.sophia.grid5000.fr,
          node100.sophia.grid5000.fr (note that step is 2) excluding machines:
          node010.sophia.grid5000.fr and node020.sophia.grid5000.fr.</para>

          <programlisting language="xml">...........................
&lt;jvm name='jvm1'&gt;
	&lt;creation&gt;
		&lt;processReference refid='processlist'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...........................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess
			class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='processlist'&gt;
		&lt;processListbyHost
			class='org.objectweb.proactive.core.process.ssh.SSHProcessList'
			hostlist='crusoe waha nahuel' domain='inria.fr'&gt;
			&lt;processReference refid='jvmProcess'/&gt;
		&lt;/processListbyHost&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;
</programlisting>

          <para>Using <emphasis role="bold">processListbyHost</emphasis>
          element allows to give a hostlist separated with a whitespace. The
          class attribute is defined as described in the processList tag. The
          <emphasis role="bold">domain</emphasis> attribute is optional since
          the complete hostname can also be provided in the hostlist
          attribute. In the example, a jvm is going to be created using ssh on
          crusoe.inria.fr, waha.inria.fr, nahuel.inria.fr.</para>

          <para>Here are complete examples of SSH deployment using <literal>processList</literal> and <literal>processListbyHost</literal>.</para>

          <programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/SSHList_example.xml"/></textobject></programlisting>
           <para>and</para>
           <programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/SSHListbyHost_Example.xml"/></textobject></programlisting>

        </listitem>

        <listitem>
          <para>LSF</para>

          <indexterm>
            <primary>Cluster</primary>
			<secondary>LSF</secondary>
          </indexterm>

          <para>This protocol is used to create Nodes (JVMs) on a cluster.
          <emphasis role="bold">ProActive</emphasis> provides
          <literal>org.objectweb.proactive.core.process.lsf.LSFBSubProcess</literal>
          to create <emphasis role="bold">bsub</emphasis> process.</para>

          <para>In this part, we assume that you want to submit a job from a
          machine which is not the cluster frontend. As described before, you
          can combine protocols. In this case , you will have to define a
          process to log on the front-end of the cluster (<emphasis role="bold">rlogin</emphasis> if your machine is on the same LAN
          than the cluster front-end, else <emphasis role="bold">ssh</emphasis> (Remember that to use <emphasis role="bold">ssh</emphasis> you will have to run some commands as
          explained above).</para>

          <programlisting language="xml">&lt;jvm name='Jvm2'&gt;
	&lt;creation&gt;
		&lt;processReference refid='sshProcess'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...................................................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='bsubInriaCluster'&gt;
		&lt;bsubProcess
			class='org.objectweb.proactive.core.process.lsf.LSFBSubProcess'&gt;
				&lt;processReference refid='jvmProcess'/&gt;
				&lt;bsubOption&gt;
					&lt;hostlist&gt;cluster_machine1 cluster_machine2&lt;hostlist/&gt;
					&lt;processor&gt;6&lt;/processor&gt;
					&lt;scriptPath&gt;
						&lt;absolutePath
							value='/home/ProActive/dist/scripts/unix/cluster/startRuntime.sh'/&gt;
					&lt;/scriptPath&gt;
				&lt;/bsubOption&gt;
		&lt;/bsubProcess&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='sshProcess'&gt;
		&lt;sshProcess
			class='org.objectweb.proactive.core.process.ssh.SSHProcess'
			hostname='sea.inria.fr'&gt;
			&lt;processReference refid='bsubInriaCluster'/&gt;
		&lt;/sshProcess&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;</programlisting>

          <para>In this example, the JVM called <emphasis role="bold">Jvm2</emphasis> will be created using <emphasis role="bold">ssh</emphasis> to log on the cluster front end. Then a
          <emphasis role="bold">bsub</emphasis> command will be generated
          thanks to the process defined by <emphasis role="bold">bsubInriaCluster</emphasis>.
		  This <emphasis role="bold">bsub</emphasis> command will create Nodes on several
          cluster machines, since <emphasis role="bold">bsubInriaCluster</emphasis> references the <emphasis role="bold">jvmProcess</emphasis> defined process. All tags defined
          under <emphasis role="bold">&lt;bsubOption&gt;</emphasis> are not
          mandatory, but they can be very useful. The &lt;hostlist&gt; tag
          defines possible candidates in the job attribution, if not set the
          job will be allocated among all cluster's machines. The
          <emphasis role="bold">&lt;processor&gt;</emphasis> tag defines the number of processor requested, if
          not set, one processor is requested. The <emphasis role="bold">&lt;resourceRequirement&gt;</emphasis>
          tag defines the expected number of processors per machine. For
          instance <emphasis role="bold">&lt;resourceRequirement value='span[ptile=2]'/&gt;</emphasis> ensures
          that 2 processors per machines will be used, whereas
          <emphasis role="bold">&lt;resourceRequirement value='span[ptile=1]'/&gt;</emphasis> forces LSF to allocate only one
          processor per machine. It represents the <emphasis role="bold">-R</emphasis> option of LSF. At last, <emphasis role="bold">&lt;scriptPath&gt;</emphasis>
          defines the path on the cluster front end of the
          <emphasis role="bold">startRuntime.sh</emphasis> script which is necessary to run ProActive on a cluster.
          This script is located under the <literal>Proactive/dist/scripts/unix/cluster</literal> directory. If not
          set the default location is set as
          <literal>~/Proactive/dist/scripts/unix/cluster</literal>.</para>

		  <newline/>
		  <newline/>
          <para>If you want to submit the job directly from the cluster entry
          point, define only the <emphasis role="bold">bsubProcess</emphasis>
          like in the previous example and skip the ssh definition.</para>

          <programlisting language="xml">&lt;jvm name='Jvm2'&gt;
	&lt;creation&gt;
		&lt;processReference refid='bsubInriaCluster'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...................................................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='bsubInriaCluster'&gt;
		&lt;bsubProcess
			class='org.objectweb.proactive.core.process.lsf.LSFBSubProcess'
			interactive='true' queue='short'&gt;
			&lt;processReference refid='jvmProcess'/&gt;
			&lt;bsubOption&gt;
				&lt;hostlist&gt;cluster_machine1 cluster_machine2&lt;hostlist/&gt;
				&lt;processor&gt;6&lt;/processor&gt;
				&lt;scriptPath&gt;
					&lt;absolutePath value='/home/ProActive/dist/scripts/unix/cluster/startRuntime.sh'/&gt;
				&lt;/scriptPath&gt;
			&lt;/bsubOption&gt;
		&lt;/bsubProcess&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;</programlisting>

          <para>Note that in the example above two new attributes has appeared: <emphasis role="bold">interactive</emphasis> and <emphasis role="bold">queue</emphasis>. They are optional, and have a
          default value: respectively <emphasis role="bold">false</emphasis>
          and <emphasis role="bold">normal</emphasis>. They represent option
          in the bsub command: interactive mode, and the name of the
          queue.</para>

		<programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/SSH_LSF_Example.xml"/></textobject></programlisting>

        </listitem>

        <listitem>
          <para>PBS</para>

          <indexterm>
            <primary>Cluster</primary>
			<secondary>PBS</secondary>
          </indexterm>

          <para>This protocol is used to create jobs on cluster managed by
          PBS, PBSPro or Torque. ProActive provides
          <literal>org.objectweb.proactive.core.process.pbs.PBSBSubProcess</literal>
          to create <emphasis role="bold">pbs</emphasis> processes. As
          explained for LSF, you can combine protocols in order to
          log on the cluster's frontal with ssh and  then to create nodes using
          PBS, or you can also use only PBS without ssh if you are already
          logged on the frontend. Example below shows how to combine an ssh
          process to log on the cluster and a PBS process that references a
          <emphasis role="bold">jvmProcess</emphasis> in order to create nodes
          on processors requested by PBS.</para>

          <programlisting language="xml">&lt;jvm name='Jvm2'&gt;
	&lt;creation&gt;
		&lt;processReference refid='sshProcess'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...................................................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='pbsCluster'&gt;
		&lt;pbsProcess class='org.objectweb.proactive.core.process.pbs.PBSSubProcess'&gt;
			&lt;processReference refid='jvmProcess'/&gt;
			&lt;pbsOption&gt;
				&lt;hostsNumber&gt;4&lt;/hostsNumber&gt;
				&lt;processorPerNode&gt;1&lt;/processorPerNode&gt;
				&lt;bookingDuration&gt;00:15:00&lt;/bookingDuration&gt;
				&lt;outputFile&gt;/home1/rquilici/out.log&lt;/outputFile&gt;
				&lt;scriptPath&gt;
					&lt;absolutePath value='/home/ProActive/dist/scripts/unix/cluster/pbsStartRuntime.sh'/&gt;
				&lt;/scriptPath&gt;
			&lt;/pbsOption&gt;
		&lt;/pbsProcess&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='sshProcess'&gt;
		&lt;sshProcess
			class='org.objectweb.proactive.core.process.ssh.SSHProcess'
			hostname='frontend'&gt;
			&lt;processReference refid='pbsCluster'/&gt;
		&lt;/sshProcess&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;</programlisting>

          <para>Note that not all options are listed here, and some options
          mentionned in the example are optional:</para>
		  <itemizedlist>
			  <listitem>
				  <para><emphasis role="bold">hostsNumber</emphasis> represents the number of host requested using pbs (default is 1)</para>
			  </listitem>
			  <listitem>
				  <para><emphasis role="bold">processorPerNode</emphasis> represents the number of
          processor per hosts requested (1 or 2, default is 1)</para>
			  </listitem>
			  <listitem>
				  <para><emphasis role="bold">bookingDuration</emphasis> represents the duration of
          the job (default is 1 minute)</para>
			  </listitem>
			  <listitem>
				  <para><emphasis role="bold">outputFile</emphasis> represents the file where to put
          the ouput of the job(default is specified by pbs)</para>
			  </listitem>
			  <listitem>
				<para><emphasis role="bold">scriptPath</emphasis> represents the location on the
				  frontend_host of the script pbsStartRuntime.sh (default is
				  <literal>/user.home/ProActive/dist/scripts/unix/cluster/pbsStartRuntime.sh</literal>)</para>
			  </listitem>
		  </itemizedlist>

			<programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/SSH_PBS_Example.xml"/></textobject></programlisting>

        </listitem>

        <listitem>
          <para>Sun Grid Engine</para>

          <indexterm>
            <primary>Cluster</primary>
			<secondary>Sun Grid Engine</secondary>
          </indexterm>

          <para>This protocol is used to create jobs on cluster managed by Sun
          Grid Engine. ProActive provides
          <literal>org.objectweb.proactive.core.process.gridengine.GridEngineSubProcess</literal>
          to create <emphasis role="bold">grid engine</emphasis> processes. As
          explained above, you can combine protocols in order to
          log on the cluster's frontal with ssh and then to create nodes using
          SGE, or you can also use only SGE without ssh if you are already
          logged on the frontend. The example below shows how to combine an ssh
          process to log on the cluster and a SGE process that references a
          <emphasis role="bold">jvmProcess</emphasis> in order to create nodes
          on processors requested by SGE.</para>

          <programlisting language="xml">&lt;jvm name='Jvm2'&gt;
	&lt;creation&gt;
		&lt;processReference refid='sshProcess'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...................................................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='sgeCluster'&gt;
		&lt;gridengineProcess class='org.objectweb.proactive.core.process.gridengine.GridEngineSubProcess'&gt;
			&lt;processReference refid='jvmProcess'/&gt;
			&lt;gridEngineOption&gt;
				&lt;hostsNumber&gt;4&lt;/hostsNumber&gt;
				&lt;bookingDuration&gt;00:15:00&lt;/bookingDuration&gt;
				&lt;scriptPath&gt;
					&lt;absolutePath value='/home/ProActive/dist/scripts/unix/cluster/gridEngineStartRuntime.sh'/&gt;
				&lt;/scriptPath&gt;
				&lt;parallelEnvironment&gt;mpi&lt;/parallelEnvironment&gt;
			&lt;/gridEngineOption&gt;
		&lt;/gridengineProcess&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='sshProcess'&gt;
		&lt;sshProcess
			class='org.objectweb.proactive.core.process.ssh.SSHProcess'
			hostname='frontend'&gt;
			&lt;processReference refid='sgeCluster'/&gt;
		&lt;/sshProcess&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;</programlisting>

          <para>As mentionned previously, many options exist, and correspond
          to the main options specified in an SGE system. For example, <emphasis role="bold">ScriptPath</emphasis> represents the location on the
          frontend_host of the script gridEngineStartRuntime.sh (default is <literal>/user.home/ProActive/dist/scripts/unix/cluster/gridEngineStartRuntime.sh</literal>).</para>

			<programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/SSH_SGE_Example.xml"/></textobject></programlisting>

        </listitem>

        <listitem>
          <para>OAR</para>

          <indexterm>
            <primary>Cluster</primary>
			<secondary>OAR</secondary>
          </indexterm>

          <para>OAR is a cluster protocol developed at INRIA Alpes and used on
          <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.grid5000.fr">Grid5000</link>. ProActive
          provides
          <literal>org.objectweb.proactive.core.process.oar.OARSubProcess</literal>
          to use such a protocol. As explained above, you can combine protocols in
          order to log on the cluster's frontend with ssh and then to
          create nodes using OAR, or you can also use only OAR without ssh if
          you are already logged on the frontend. The example below shows how to
          combine an ssh process to log on the cluster, then an OAR process
          that references a <emphasis role="bold">jvmProcess</emphasis> in
          order to create nodes on processors requested by OAR.</para>

          <programlisting language="xml">&lt;jvm name='Jvm2'&gt;
	&lt;creation&gt;
		&lt;processReference refid='sshProcess'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...................................................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='oarCluster'&gt;
		&lt;oarProcess class='org.objectweb.proactive.core.process.oar.OARSubProcess'&gt;
			&lt;processReference refid='jvmProcess'/&gt;
			&lt;oarOption&gt;
				&lt;resources&gt;node=2,weight=2&lt;/resources&gt;
				&lt;scriptPath&gt;
					&lt;absolutePath value='/home/ProActive/dist/scripts/unix/cluster/oarStartRuntime.sh'/&gt;
				&lt;/scriptPath&gt;
			&lt;/oarOption&gt;
		&lt;/oarProcess&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='sshProcess'&gt;
		&lt;sshProcess
			class='org.objectweb.proactive.core.process.ssh.SSHProcess'
			hostname='frontend'&gt;
			&lt;processReference refid='oarCluster'/&gt;
		&lt;/sshProcess&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;</programlisting>

          <para>As mentionned previously, many options exist, and correspond
          to the main options specified in an OAR system. For example, <emphasis role="bold">ScriptPath</emphasis> represents the location on the
          frontend host of the script oarStartRuntime.sh (default is
          <literal>/user.home/ProActive/dist/scripts/unix/cluster/oarStartRuntime.sh</literal>).</para>
          <programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/SSH_OARGRID_Example.xml"/></textobject></programlisting>

        </listitem>

        <listitem>
          <para>PRUN</para>

          <indexterm>
            <primary>Cluster</primary>
			<secondary>PRUN</secondary>
          </indexterm>

          <para>PRUN is a cluster protocol developed at Amsterdam to manage
          their <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.cs.vu.nl/das/prun/prun.1.html">cluster</link>.
          ProActive provides <literal>org.objectweb.proactive.core.process.prun.PrunSubProcess</literal>
          to use such a protocol.</para>

			<programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/SSH_PRUN_Example.xml"/></textobject></programlisting>

        </listitem>

        <listitem>
          <indexterm significance="preferred">
            <primary>Globus</primary>
            <secondary>XML Descriptor</secondary>
          </indexterm>

          <para>GLOBUS</para>

          <para>Like <emphasis role="bold">ssh</emphasis>, using <emphasis role="bold">Globus</emphasis> requires some steps to be performed.
          In particular the <emphasis role="bold">java COG Kit</emphasis> (no
          need for the whole GT) must be installed on the machine that will
          originates the <emphasis role="bold">RSL</emphasis> request. See
          <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.cogkit.org/">COG Kit Installation</link> to know
          how to install the client kit. Then you have to initialize your
          proxy by running <emphasis role="bold">COG_INSTALLATION/bin
          /grid-proxy-init</emphasis>. You will be asked for a passphrase, which
          is the one you provided when requesting a user certificate at
          globus.org. Once these steps are performed, you can run <emphasis role="bold">ProActive</emphasis> application using <emphasis role="bold">GRAM</emphasis> protocol.</para>

          <para><emphasis role="bold">ProActive</emphasis> provides
          <literal>org.objectweb.proactive.core.process.globus.GlobusProcess</literal>
          to create <emphasis role="bold">globus</emphasis> process.</para>

          <indexterm>
            <primary>Globus</primary>
            <secondary>XML Descriptor</secondary>
            <tertiary>GlobusProcess</tertiary>
          </indexterm>

          <programlisting language="xml">&lt;jvm name='Jvm2'&gt;
	&lt;creation&gt;
		&lt;processReference refid='globusProcess'/&gt;
	&lt;/creation&gt;
&lt;/jvm&gt;
...................................................
&lt;processes&gt;
	&lt;processDefinition id='jvmProcess'&gt;
		&lt;jvmProcess class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
	&lt;/processDefinition&gt;
	&lt;processDefinition id='globusProcess'&gt;
		&lt;globusProcess
			class='org.objectweb.proactive.core.process.globus.GlobusProcess'
			hostname='globus1.inria.fr'&gt;
			&lt;processReference refid='jvmProcess'/&gt;
			&lt;environment&gt;
				&lt;variable name='DISPLAY' value='machine_name0.0'/&gt;
			&lt;/environment&gt;
			&lt;globusOption&gt;
				&lt;count&gt;10&lt;/count&gt;
			&lt;/globusOption&gt;
		&lt;/globusProcess&gt;
	&lt;/processDefinition&gt;
&lt;/processes&gt;</programlisting>

          <para>In this example, <emphasis role="bold">Jvm2</emphasis> will be
          created using <emphasis role="bold">GRAM</emphasis>. An <emphasis role="bold">RSL</emphasis> request will be generated with
          information provided in the descriptor. For instance, the
          &lt;environment&gt; tag is not mandatory, but for the globus host to
          export the DISPLAY on your machine, you can define the value in the
          descriptor as well as other environment variable, except the
          classpath (or java path,...) which must be defined in the <emphasis role="bold">jvmProcess</emphasis> referenced by <emphasis role="bold">globusProcess</emphasis> as explained before.
          &lt;globusOption&gt; is not mandatory either. Default value for
          &lt;count&gt; element is 1. It represents the number of requested processor.
          </para>
			<programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/Globus_Example.xml"/></textobject></programlisting>
        </listitem>

        <listitem>
          <para>ARC (NorduGrid):</para>

          <para>ProActive provides
          <literal>org.objectweb.proactive.core.process.nordugrid.NGProcess</literal>
          to use such a protocol.</para>

          <para>To use ARC you will need to download the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ftp.nordugrid.org/download/index.html">ARC
          Client</link>. </para>
			<programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/NorduGrid_Example.xml"/></textobject></programlisting>

        </listitem>

        <listitem>
          <para>MPI</para>

          <para>ProActive provides
          <literal>org.objectweb.proactive.core.process.mpi.MPIDependentProcess</literal>
          to use such a protocol. You have to couple this process with the
          DependentListProcessDecorator explained below.</para>

			<para>Here is the complete example that you can find within the ProActive distribution.</para>
			<programlisting language="xml"><textobject><textdata fileref="../../../descriptors/examples_legacy_descriptors/SSH_MPI_Example.xml"/></textobject></programlisting>
        </listitem>
      </itemizedlist>

    </section>

    <section xml:id="DependentListProcessDecorator_1"><info><title>DependentListProcessDecorator</title></info>


      <para>This process is used when a process is dependent on an another
      process. The first process of the list can be any process but the second
      one must be a DependentProcess. Thus the second one has to implement the
      <literal>org.objectweb.proactive.core.process.DependentProcess</literal> interface.</para>

      <programlisting language="xml">&lt;!-- mpi Process --&gt;
&lt;processDefinition id="mpiCPI"&gt;
	&lt;mpiProcess
		class="org.objectweb.proactive.core.process.mpi.MPIDependentProcess"
		mpiFileName="cpi"&gt;
		&lt;commandPath value="${MPIRUN_PATH}" /&gt;
		&lt;mpiOptions&gt;
			&lt;processNumber&gt;3&lt;/processNumber&gt;
			&lt;localRelativePath&gt;
				&lt;relativePath origin="user.home"
					value="${PROACTIVE_HOME}/scripts/unix" /&gt;
			&lt;/localRelativePath&gt;
			&lt;remoteAbsolutePath&gt;
				&lt;absolutePath value="${REMOTE_HOME}/MyApp" /&gt;
			&lt;/remoteAbsolutePath&gt;
		&lt;/mpiOptions&gt;
	&lt;/mpiProcess&gt;
&lt;/processDefinition&gt;

&lt;!-- dependent process --&gt;
&lt;processDefinition id="dpsCPI"&gt;
	&lt;dependentProcessSequence
		class="org.objectweb.proactive.core.process.DependentListProcess"&gt;
		&lt;processReference refid="pbsProcess" /&gt;
		&lt;processReference refid="mpiCPI" /&gt;
	&lt;/dependentProcessSequence&gt;
&lt;/processDefinition&gt;

&lt;!-- ssh process --&gt;
&lt;processDefinition id="sshProcess"&gt;
	&lt;sshProcess
		class="org.objectweb.proactive.core.process.ssh.SSHProcess"
		hostname="nef.inria.fr" username="smariani"&gt;
		&lt;processReference refid="dpsCPI" /&gt;
	&lt;/sshProcess&gt;
&lt;/processDefinition&gt;
		</programlisting>

		<para>We can notice in this example that the second process of the DependentListProcess (mpiCPI)
		instantiate the <literal>org.objectweb.proactive.core.process.mpi.MPIDependentProcess</literal> class
		which, as required above, implements the <literal>org.objectweb.proactive.core.process.DependentProcess</literal> interface.</para>
    </section>
  </section>

  <section xml:id="Descriptor_html_services"><info><title xml:id="Infrastructureandservices_1">Infrastructure and services</title></info>


    <para>As mentionned previously, instead of creating jvms, ProActive gives
    the possibility to acquire existing jvms. To do so, as shown in the
    example below, a service must be referenced in the <emphasis role="bold">acquisition</emphasis> tag. At this point one service is
    implemented: <emphasis role="bold">RMIRegistryLookup</emphasis>.
	The RMIRegistryLookup
    service performs a lookup in an RMIRegistry at the <emphasis role="bold">url specified in the service definition</emphasis> to find a
    ProActiveRuntime (a JVM) with the given name.</para>

    <programlisting language="xml">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;ProActiveDescriptor
	xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
	xsi:noNamespaceSchemaLocation='DescriptorSchema.xsd'&gt;
	&lt;componentDefinition&gt;
		&lt;virtualNodesDefinition&gt;
			&lt;virtualNode name='VnTest' property='multiple'/&gt;
		&lt;/virtualNodesDefinition&gt;
	&lt;/componentDefinition&gt;
	&lt;deployment&gt;
		&lt;mapping&gt;
			&lt;map virtualNode='VnTest'&gt;
				&lt;jvmSet&gt;
					&lt;vmName value='Jvm1'/&gt;
				&lt;/jvmSet&gt;
			&lt;/map&gt;
		&lt;/mapping&gt;
		&lt;jvms&gt;
			&lt;jvm name='Jvm1'&gt;
				&lt;acquisition&gt;
					&lt;serviceReference refid='lookupRMI'/&gt;
				&lt;/acquisition&gt;
			&lt;/jvm&gt;
		&lt;/jvms&gt;
	&lt;/deployment&gt;
	&lt;infrastructure&gt;
		&lt;services&gt;
			&lt;serviceDefinition id='lookupRMI'&gt;
				&lt;RMIRegistryLookup url='//localhost:2020/PA_JVM1'/&gt;
			&lt;/serviceDefinition&gt;
		&lt;/services&gt;
	&lt;/infrastructure&gt;
&lt;/ProActiveDescriptor&gt;</programlisting>

    <para>The <emphasis role="bold">RMIRegistryLookup</emphasis> service needs
    only an <emphasis role="bold">URL</emphasis> to perform the lookup.</para>

    <para>The example above shows a VirtualNode <emphasis role="bold">VnTest</emphasis>, that is mapped to one JVM, <emphasis role="bold">Jvm1</emphasis>.
	<emphasis role="bold">Jvm1</emphasis> represents a JVM that will be acquired using an RMI Lookup.</para>

    <para>
		Fault Tolerance can also be defined at the service level. See
		<link xlink:href="../../AdvancedFeatures/multiple_html/FaultTolerance.html">Chapter 32. Fault-Tolerance</link>
		for more information.
	</para>
  </section>


  <section xml:id="Processes_1"><info><title>Processes</title></info>

    <para>ProActive provides
    also the ability to use all processes defined above without using XML
    Deployment Descriptor. You can programmatically create such
    processes.</para>

    <para>In order to get familiar on how to create processes
    programmatically, see the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="../../api_complete/org/objectweb/proactive/core/process/package-summary.html">javadoc of the org.objectweb.proactive.core.process package</link>.</para>

	<para>For instance, you can create an SSH process as follows:</para>

	<programlisting language="java">SSHProcess ssh = new SSHProcess(new SimpleExternalProcess("ls -lsa"));
ssh.setHostname("kisscool.inria.fr");
ssh.startProcess();</programlisting>

	<para>This piece of code will create an SSHProcess in charge of executing the <literal>ls -lsa</literal> command on <literal>kisscool.inria.fr</literal>.</para>
  </section>

  <section xml:id="DescriptorFileTransfer_67"><info><title>Descriptor File Transfer</title></info>

    <para>As it is explained in <xref linkend="FileTransfer" />, ProActive provides a File Transfer mechanism which enables
	to transfer a file from a node to another one. File transfers are normally done through the ProActive API.
	however, File Transfers can also be specified using ProActive Descriptors.
    The main advantage of this scheme is that it allows deployment and
    retrieval of input and output (files). In this section we will concentrate
    on mainly three topics:</para>

    <itemizedlist>
      <listitem>
        <para>XML Descriptor File Transfer Tags</para>
      </listitem>

      <listitem>
        <para>Deployment File Transfer</para>
      </listitem>

      <listitem>
        <para>Retrieval File Transfer</para>
      </listitem>
    </itemizedlist>

    <section xml:id="XMLDescriptorFileTransferTags_67"><info><title>XML Descriptor File Transfer Tags</title></info>


      <para>The File Transfer related tags, are placed inside the descriptor
      at three different parts (or levels).</para>

      <para>The first one corresponds to the <emphasis role="bold">fileTransferDefinitions</emphasis> tag, which contains a
      list of FileTransfer definitions. A FileTransfer definition is a high
      level representation of the File Transfer, containing mainly the file
      names. It is created in such a way, that no low level information such
      as: hosts, protocols, prefix is present (this is the role of the low
      level representation). The following example shows a FileTranfer
      definition named <emphasis>example</emphasis> which has to placed between the <emphasis role="italics">deployment</emphasis>
	  and the <emphasis role="italics">infrastructure</emphasis> tag:</para>

	  <programlisting language="xml"><textobject><textdata fileref="automatic_snippets/FileTransfer_1.snip"/></textobject></programlisting>


      <para>The FileTransfer definitions can be referenced through their
      names, from the <emphasis role="bold">VirtualNode</emphasis> tags using
      two attributes:<emphasis role="bold">fileTransferDeploy</emphasis> and
      <emphasis role="bold">fileTransferRetrieve</emphasis>. The first one,
      corresponds to the file transfer that will take place at deployment
      time, and the second one corresponds to the file transfer that the user
      will trigger once the user application is done.</para>

	  <programlisting language="xml"><textobject><textdata fileref="automatic_snippets/FileTransfer_2.snip"/></textobject></programlisting>

      <para>All the low level information such as: hosts, username, protocols,
      prefix, etc... is declared inside each process. Both <emphasis role="bold">fileTransferDeploy</emphasis> and <emphasis role="bold">fileTransferRetrieve</emphasis> are specified separately
      using a <emphasis role="bold">refid</emphasis> attribute. The <emphasis role="bold">refid</emphasis> can be a direct reference to a FileTransfer
      definition, or the keyword <emphasis role="bold">implicit</emphasis>. If <emphasis role="bold">implicit</emphasis> is used, then the reference will be
      inherited from the corresponding VirtualNode. In the following example
      both mechanisms (Deploy and Retrieve) reference indirectly and directly
      the example definition:</para>

	  <programlisting language="xml"><textobject><textdata fileref="automatic_snippets/FileTransfer_3.snip"/></textobject></programlisting>

      <indexterm>
        <primary>CopyProtocol</primary>
      </indexterm>

      <para>In the example above, <emphasis role="bold">fileTransferDeploy</emphasis> has an implicit refid. This
      means that the File Transfer definitions used will be inherited from the
      VirtualNode. The first element shown inside this tag corresponds to
      <emphasis role="bold">copyProtocol</emphasis>. The <emphasis role="bold">copyProtocol</emphasis> tag specified the sequence of
      protocols that will be executed to achieve the FileTransfer at
      deployment time. Notice the <emphasis role="bold">processDefault</emphasis> keyword, which specifies the usage
      of the default copy protocol associated with this process. In the case
      of the example, this corresponds to an <emphasis role="bold">sshProcess</emphasis>
      and therefore the Secure Copy Protocol (scp) will be tried first. To
      complement the higher level File Transfer definition, other information
      can be specified as attributes in the <emphasis role="bold">sourceInfo</emphasis> and <emphasis role="bold">destinationInfo</emphasis> elements.
	  In this example, we provide a <emphasis role="bold">prefix</emphasis> attribute that indicates from and to which directory the file should be transferred.
      Other attributes such as <emphasis>hostname</emphasis> and
      <emphasis>username</emphasis> can also be given.</para>

      <para>For <emphasis role="bold">fileTransferRetrieve</emphasis>, no
      copyProtocol needs to be specified. ProActive will use its internal
      mechanism to transfer the files. This implies that no
      <emphasis>hostname</emphasis> or <emphasis>username</emphasis> are
      required.</para>
	</section>

	<section xml:id="Currentlysupportedprotocolsforfiletransferdeployment"><info><title>Supported protocols for file transfer deployment</title></info>

		<para>The supported protocols for file transfer are the following one:</para>

        <para><itemizedlist>
            <listitem>
              <para><emphasis role="bold">pftp</emphasis> (ProActive File Transfer Protocol)</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">scp</emphasis> (ssh processDefault)</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">rcp</emphasis> (rsh processDefault)</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">nordugrid</emphasis> (Nordugrid processDefault)</para>
            </listitem>
          </itemizedlist></para>
      </section>

      <section xml:id="TriggeringFileTransferDeploy_67"><info><title>Triggering File Transfer Deploy</title></info>


        <para>The start of the File Transfer will take place when
        the deployment of the descriptor file is executed. In the case of
        <emphasis>external protocols</emphasis> (<emphasis role="bold">scp,
        rcp</emphasis>), this will take place before the process deployment.
        In the case of <emphasis>internal protocols</emphasis> (<emphasis role="bold">nordugrid</emphasis>), this will take place with
        the process deployment. In any case, it should be noted that
        interesting things can be achieved, such as transfering the ProActive
        libraries into the deploying machine using an <emphasis role="bold">on-the-fly</emphasis> style. This means that it is
        possible to deploy on remote machines without having ProActive
        <emphasis>pre-installed</emphasis>. Even further, when the network
        allows, it is also possible to transfer other required libraries like
        the JRE (Java Runtime Environment).</para>

        <para>There is one protocol that behaves differently from the others:
        the ProActive FileTransfer Protocol (<emphasis role="bold">pftp</emphasis>). <emphasis role="bold">pftp</emphasis> uses the ProActive FileTranfer API
        (described in <xref linkend="FileTransfer" />), to transfer files between nodes. The main
        advantage of using the <emphasis role="bold">pftp</emphasis> is that
        no external copy protocols are required to transfer files at
        deployment time. Therefore, if the grid infrastructure does not
        provide a way to transfer files, a FileTransfer Deploy can still take
        place using the <emphasis role="bold">pftp</emphasis>. On the other
        hand, the main drawback of using <emphasis role="bold">pftp</emphasis>
        is that ProActive must already be install on the remote machines, and
        thus <emphasis role="bold">on-the-fly</emphasis> deployment is not
        possible.</para>
      </section>

      <section xml:id="TriggeringFileTransferRetrieve_67"><info><title>Triggering File Transfer Retrieve</title></info>


        <para>Since distributed application's termination is difficult to
        detect. The responsibility of triggering the deployment corresponds to
        the user. To achieve this, we have provided a specific method that will
        trigger the retrieval of all files associated with a
        VirtualNode.</para>

		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/FileTransfer_4.snip"/></textobject></programlisting>

        <para>This will trigger the retrieval of all the files specified in
        the descriptor, from all the nodes that were deployed using this
        virtual node using the <emphasis role="bold">pftp</emphasis>.
        </para>

        <para>As a result of calling this method, a list of <literal>RemoteFile</literal> will
        be created, representing all the retrieved files.</para>
      </section>


	  <section xml:id="dbdoclet.id.FileTransfer_html_design" xreflabel="FileTransfer Design"><info><title xml:id="AdvancedFileTransferDesign_67">Advanced: FileTransfer Design</title></info>

		<para>This section provides internal details and information on how the
		File Transfer is implemented. Reading this section to use the
		File Transfer mechanisms provided by ProActive is not necessary.</para>

		<section xml:id="AbstractDefinitionHighlevel_67"><info><title>Abstract Definition (High level)</title></info>


		  <para>These definitions can be referenced from a VirtualNode. They
		  contain the most basic information of a FileTransfer:</para>

		  <itemizedlist>
			<listitem>
			  <para><emphasis role="bold">id</emphasis> attribute - A unique identification name.</para>
			</listitem>

			<listitem>
			  <para><emphasis role="bold">file</emphasis> element - source and optionally destination file name.</para>
			</listitem>

			<listitem>
			  <para><emphasis role="bold">dir</emphasis> element - source and optionally destination directory name.</para>
			</listitem>
		  </itemizedlist>

		  <para>References from the VirtualNode are made using the unique
		  definition name.</para>
		</section>

		<section xml:id="ConcreteDefinitionLowlevel_67"><info><title>Concrete Definition (Low level)</title></info>


		  <para>These definitions contain more architecture specific information,
		  and are therefore contained within the Process:</para>

		  <itemizedlist>
			<listitem>
			  <para><emphasis role="bold">refid</emphasis> attribute: A reference to an abstract definition, or the "<emphasis role="bold">implicit</emphasis>" key word indicating that the reference
			  will be inherited from the VirtualNode.</para>
			</listitem>

			<listitem>
			  <para><emphasis role="bold">copyProtocols</emphasis> element: A sequence of Copy Protocols that will be used.</para>
			</listitem>

			<listitem>
			  <para><emphasis role="bold">sourceInfo</emphasis> and <emphasis role="bold">destinationInfo</emphasis> element: Source and Destination information (prefix, username,
			  hostname, file separator, etc.)</para>
			</listitem>
		  </itemizedlist>

		  <para>If some of this information (like username or hostname) can be
		  inferred from the process, it is not necessary to declare it in the
		  definition. Optionally, information contained in the protocol can be
		  overridden if specified.</para>
		</section>

		<section xml:id="HowDeploymentFileTransferWorks_67"><info><title>How Deployment File Transfer Works</title></info>


		  <figure xml:id="FileTransferDesign_67"><info><title>File Transfer Design</title></info>


			<mediaobject>
			  <imageobject>
				<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/fileTransferDesign.png" format="PNG"/>
			  </imageobject>
			</mediaobject>
		  </figure>

		  <para>When a FileTransfer starts, both abstract and concrete information
		  are merged using the FileTransfer Workshop. The result of this process
		  corresponds to a sequence of CopyProtocols, as specified in the Concrete
		  Definition.</para>

		  <para>Each CopyProtocol will be tried before the deployment takes place,
		  until one succeeds. Once one succeeded or all failed, the process
		  deployment will take place.</para>
		</section>

	  </section>
		</section>
</chapter>
