<?xml version="1.0" encoding="utf-8"?>
	<appendix xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="FAQ"><info><title xml:id="FrequentlyAskedQuestions_3">Frequently Asked Questions</title></info>


	<para>
		<emphasis role="bold">Note:</emphasis> This FAQ is under construction.
		If one of your question is not answered here, just send it at
		<email>proactive@ow2.org</email> and we will update the FAQ.
	</para>

	<qandaset>
		<qandadiv xml:id="FrequentlyAskedQuestions_main"><title>Frequently Asked Questions</title>
		<qandaentry>
			<question xml:id="HowDoIBuildProActiveFromTheDistribution">
				<para>How do I build ProActive from the distribution?</para>
			</question>

			<answer>
				<para>ProActive uses
				<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://jakarta.apache.org/ant/">Ant</link> for its build.
				Assuming that the environment variable <literal>JAVA_HOME</literal>
				is properly set to your Java distribution, just go into the
				<literal>compile</literal> directory and use the script:</para>

				<itemizedlist>
					<listitem> <para>on Windows: <literal>build.bat deploy.all</literal></para> </listitem>
					<listitem> <para>on Unix systems: <literal>build deploy.all</literal></para> </listitem>
				</itemizedlist>

				<para>
					<literal>'deploy.all'</literal>  represents the target of the
					build. This target will compile all sources files and generate the JAR files in the <filename>dist/lib</filename>
					directory.
				</para>

				<para>
					If you want only to compile only parts of ProActive,
					you should try <literal>build</literal>, with no arguments.
					You should see the following output:
				</para>

				<screen><textobject><textdata fileref="code_snippets/build-output.txt" /></textobject></screen>

			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="WhydonttheexamplesandcompilationworkunderWindows">
				<para>Why don't the examples and compilation work under Windows?</para>
			</question>

			<answer>
				<indexterm><primary>Microsoft Windows</primary><secondary>Running ProActive</secondary></indexterm>

				<para>
					It happens quite often, that the default installation
					directory under Windows is under Program Files which contains a space.
					Then setting the JAVA_HOME environment variable to the install
					directory, might be a problem for bat files (all windows examples,
					and compilation are run with bat files). To get rid of those
					problems, the best thing is to install jdk in a directory whose name
					does not contain spaces such as C:\java\j2sdk... or
					D:\java\j2sdk... and then to set the JAVA_HOME environment variable
					accordingly: set JAVA_HOME=C:\java\j2sdk... Another solution is to
					do a copy paste of the command defined in the bat file in the DOS
					window.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="permission_denied_when_launching_scripts_in_linux">
				<para>
					Why do I get a Permission denied when trying to launch
					examples scripts under Linux?
				</para>
			</question>

			<answer>
				<para>
					According to the tool used to unpackage the ProActive
					distribution, permissions of newly created files can be based on
					default UMASK permissions. If you get a permission denied, just run
					the command:
					<screen>chmod 755 */*.sh</screen>
					in the <literal>ProActive/scripts/unix</literal> directory
					in order to change permissions.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="how_does_the_node_creation_happen">
				<para>How does the node creation happen?</para>
			</question>

			<answer>
				<para>
					An active object is always attached to a node. A node
					represents a logical entity deployed onto a JVM. When creating a
					new active object, you have to provide an URL or a reference to a
					node. That node has to exist at the moment you create the active
					object. It has to be launched on a local or on a remote JVM. In
					order to be accessible from any remote JVM, a node automatically
					registers itself in the local RMI Registry on the local machine.
					Getting a reference to a remote node ends up doing a lookup into a
					RMI registry. The class <literal>NodeFactory</literal> provides a
					method <literal>getNode</literal> for doing that.
				</para>

				<para>
					In order to start a node, you can use the
					<literal>startNode[.sh|.bat]</literal> script located in the
					<literal>ProActive/bin</literal> directory.
					<literal>startNode</literal> can only start a node on the
					local machine. It is not possible to start a remote node using
					<literal>startNode</literal>. The reason is that starting a node on a remote host
					implies the use of protocol such as RSH, SSH or rLogin that are
					platform dependant and that cannot be easily abstracted from java.
					If you want to remotely start a node, you should have a look at
					<xref linkend="GCMDeployment" />.
				</para>

				<para>
					It is nevertheless possible to create an object on a remote
					node once it is created. On host X, once you have started a
					new node using <literal>startNode</literal>:
				</para>

				<screen>startNode.sh ///node1</screen>

				<para>you can create an active object from host Y on host X as follows:</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/faq_1.snip" /></textobject></programlisting>

				<para>
					You do not need to start any rmi registry manually as they are
					started automatically.
				</para>

				<para>
					As we support other ways of registration and discovery (such
					as HTTP), getting a node can be protocol dependent. For instance,
					the URL of a node <literal>http://host.org/node</literal> will not be
					accessed the same way as <literal>rmi://host.org/node</literal>. The
					class <literal>NodeFactory</literal> is able to read the protocol
					and to use the right way to access the node.
				</para>

				<para>
					When an active object is created locally without specifying a
					node, it is automatically attached to a default node. The default
					node is created automatically by <emphasis role="bold">ProActive</emphasis> on the local JVM when a first
					active object is created without a given node. The name of the
					default node is generated, based on a random number.
				</para>
			</answer>
		</qandaentry>


		<qandaentry>
			<question xml:id="how_does_the_rmi_creation_happen">
				<para>How does the RMI Registry creation happen?</para>
			</question>

			<answer>
				<para>
					<emphasis role="bold">ProActive</emphasis> relies on the RMI
					Registry for registering and discovering nodes. For this reason, the
					existence of a RMI Registry is necessary for
					<emphasis role="bold">ProActive</emphasis> to be used. In order to simplify
					the deployment of <emphasis role="bold">ProActive</emphasis>
					applications, we have included the creation of the RMI Registry with
					the creation of nodes. Therefore, if no RMI Registry exists on the
					local machine, <emphasis role="bold">ProActive</emphasis> will
					automatically create one. If one exists,
					<emphasis role="bold">ProActive</emphasis> will automatically use it.
				</para>
			</answer>
		</qandaentry>



		<qandaentry>
			<question xml:id="what_is_the_class_server">
				<para>What is the class server, why do we need it?</para>
			</question>

			<answer>
				<para>
					In the RMI model, a class server is a HTTP Server able to
					answer simple HTTP requests for getting class files. It is needed in
					the case an object being sent to a remote location where the class
					the object belongs to is unknown. In such a case, if the property
					<literal>java.rmi.server.codebase</literal> has been set properly to
					an existing class server, RMI will attempt to download the missing
					class files.
				</para>

				<para>
					Since <emphasis role="bold">ProActive</emphasis> makes use
					of on-the-fly, in memory, generated classes (the stubs), a class
					server is necessary for each JVM using active objects. For this
					reason, <emphasis role="bold">ProActive</emphasis> starts
					automatically one small class server per JVM. The launching and the
					use of this class server is transparent to you.
				</para>
			</answer>
		</qandaentry>

		<qandaentry xml:id="reifiableDefinition">
			<question xml:id="what_is_a_reifiable_object">
				<para>What is a reifiable object?</para>
			</question>

			<answer>
				<para>
					An object is said to be reifiable if it meets some
					criteria in order to become an Active Object:
				</para>

				<itemizedlist>
					<listitem>
						<para>The object is not of primitive type</para>
					</listitem>

					<listitem>
						<para>The class of the object is not final</para>
					</listitem>

					<listitem>
						<para>The object has a constructor with no arguments</para>
					</listitem>
				</itemizedlist>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="what_is_the_body">
				<para>
					What is the body of an active object? What are its local and
					remote representations?
				</para>
			</question>

			<answer>
				<para>
					Once created, an active object is associated with a Body that
					is the entity managing all the non functional properties of the
					active object. The body contains the request queue receiving all
					reified method calls to the reified object (the object from which
					the active object has been created). It is responsible for storing
					pending requests and serving them accordingly to a given
					synchronization policy, which default behavior is FIFO.
				</para>

				<para>
					The body of the active object should be the only object able
					to access directly the reified object. All other objects accessing
					the active object do so through the stub-proxy couple that
					eventually sends a request to the body. The body owns its own thread
					that represent the activity of the active object.
				</para>

				<para>
					The body has two representations. One is local and given by
					the interface <literal>Body</literal>:
					<programlisting language="java"><textobject><textdata fileref="automatic_snippets/body.snip"/></textobject></programlisting>
					This is the
					local view of the body an object can have when being in the same JVM
					as the body. For instance, the implementation of the activity of an
					object done through the method <literal>runActivity(Body)</literal>
					of the interface <literal>RunActive</literal> sees the body locally
					as it is instantiated by the body itself. The other representation,
					given by the interface <literal>UniversalBody</literal>, is remote.

					It represents the view of the body that a remote object can have
					and therefore the methods that can be invoked. That view is the one
					used by the proxy of a remote reference to the active object to send
					requests to the body of the active object.
					<programlisting language="java"><textobject><textdata fileref="automatic_snippets/universalbody.snip"/></textobject></programlisting>
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="what_is_the_stub">
				<para>What is a ProActive stub?</para>
			</question>

			<answer>
				<para>
					When you create an active object from a regular object, you
					get in return a reference on an automatically generated
					<emphasis role="bold">ProActive</emphasis> stub.
					<emphasis role="bold">ProActive</emphasis> uses
					<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://asm.objectweb.org/">ASM</link> to generate the stub on
					the fly. Supposing you have a class <literal>A</literal> and an
					instance <literal>a</literal> of this class, a way to turn the
					instance <literal>a</literal> into an active object is to use the
					method <literal>PAActiveObject.turnActive</literal>:
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/faq_2.snip"/></textobject></programlisting>

				<para>
					In the code above, the variable <literal>a</literal> is a
					direct reference onto the instance of <literal>A</literal> stored
					somewhere in memory. In contrast, the variable
					<literal>activeA</literal> is a direct reference onto an instance of
					the generated ProActive stub for the class <literal>A</literal>. By
					convention, the ProActive stub of a class <literal>A</literal> is a
					class generated in memory by ProActive that inherits from
					<literal>A</literal> and that is stored in the package
					<literal>pa.stub</literal> as <literal>pa.stub.&lt;package of A&gt;.Stub_A</literal>. The
					ProActive stub of a class redefines all public methods to reify them
					through a generic proxy. The proxy changes all method calls into
					requests that are sent to the body associated to the reified object
					(the object pointed by <literal>a</literal> in our example).
				</para>

				<para>
					The reified object can be indifferently in the same virtual
					machine as the active reference or in another one.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="are_calls_always_asynchronous">
				<para>Are the call to an active object always asynchronous?</para>
			</question>

			<answer>
				<para>No. Calls to an active object methods are asynchronous under
					some conditions. This is explained in
					<xref linkend="FutureObjectCreation"/>. If, for instance, the
					return type of a method call is not reifiable, you can use wrappers
					to keep asynchronism capabilities. Let's suppose that one of your object
					has such a method:
				</para>

				<programlisting language="java">int getNumber();</programlisting>

				<para>
					Calling this method with ProActive is synchronous since the 'int'
					type is not reifiable. To keep asynchronism, it is advised to
					use the classes given in the
					<literal>org.objectweb.proactive.core.util.wrapper</literal>
					package, or to create your own wrapper based on these examples. In
					your case, you should use:
				</para>

				<programlisting language="java">IntWrapper getNumber();</programlisting>

				<para>
					Thus, this new <literal>getNumber()</literal> method is
					asynchronous. Remember that
					<emphasis role="bold">only the methods return type are concerned</emphasis>,
					not the parameters.
				</para>
			</answer>
		</qandaentry>


		<qandaentry>
			<question xml:id="no_class_def_found_exception">
				<para>Why do I get a <literal>java.lang.NoClassDefFoundError</literal> exception about asm?</para>
			</question>

			<answer>
				<para>
					ProActive uses <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://asm.objectweb.org/">ASM</link> for the on-the-fly
					generation of stub classes. The library <literal>asm.jar</literal>,
					provided in the directory <literal>Proactive/lib</literal> is needed in order to function properly for any active
					object. If the library is not in the
					<literal>CLASSPATH</literal>, you will get the following exception or
					a similar one:
				</para>

				<screen>Exception in thread 'main' java.lang.NoClassDefFoundError: org/objectweb/asm/Constants
	at java.lang.ClassLoader.defineClass0(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:509)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:246)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:54)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:193)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:186)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:265)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:262)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:322)
	at org.objectweb.proactive.core.mop.MOP.&lt;clinit&gt;(MOP.java:88)
	at org.objectweb.proactive.MOP.createStubObject(MOP.java:836)
	at org.objectweb.proactive.MOP.createStubObject(MOP.java:830)
	at org.objectweb.proactive.PAActiveObject.newActive(PAActiveObject.java:255)
	at org.objectweb.proactive.PAActiveObject.newActive(PAActiveObject.java:180)
	at org.objectweb.proactive.examples.binarytree.TreeApplet.main(TreeApplet.java:103)</screen>

				<para>
					The problem can simply be fixed by adding <literal>asm.jar</literal> in the
					<literal>CLASSPATH</literal>.
				</para>

				<indexterm><primary>CLASSPATH</primary><secondary>missing</secondary></indexterm>
			</answer>
		</qandaentry>


		<qandaentry>
			<question xml:id="bcel_no_class_def_found_exception">
				<para>Why do I get a <literal>java.lang.NoClassDefFoundError</literal> exception about bcel?</para>
			</question>

			<answer>

				<para>
					ProActive also uses <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://jakarta.apache.org/bcel/">BCEL</link> for
					the on-the-fly generation of stub classes. The library
					<literal>bcel.jar</literal>, provided in the directory
					<literal>Proactive/lib</literal>
					is needed in order to function properly for any active object. If
					the library is not in the <literal>CLASSPATH</literal> you will get
					the following exception or a similar one:i
				</para>

				<screen>Exception in thread 'main' java.lang.NoClassDefFoundError: org/apache/bcel/generic/Type
	at org.objectweb.proactive.core.mop.MOPClassLoader.loadClass(MOPClassLoader.java:129)
	at org.objectweb.proactive.core.mop.MOPClassLoader.loadClass(MOPClassLoader.java:109)
	at org.objectweb.proactive.core.mop.MOP.createStubClass(MOP.java:341)
	at org.objectweb.proactive.core.mop.MOP.findStubConstructor(MOP.java:376)
	at org.objectweb.proactive.core.mop.MOP.createStubObject(MOP.java:443)
	at org.objectweb.proactive.core.mop.MOP.newInstance(MOP.java:165)
	at org.objectweb.proactive.core.mop.MOP.newInstance(MOP.java:137)
	at org.objectweb.proactive.MOP.createStubObject(MOP.java:590)
	at org.objectweb.proactive.MOP.createStubObject(MOP.java:585)
	at org.objectweb.proactive.PAActiveObject.newActive(PAActiveObject.java:170)
	at org.objectweb.proactive.PAActiveObject.newActive(PAActiveObject.java:137)
	at DiscoveryManager.main(DiscoveryManager.java:226)</screen>

				<para>
					The problem can simply be fixed by adding
					<literal>bcel.jar</literal> in the <literal>CLASSPATH</literal>.
				</para>

				<indexterm><primary>CLASSPATH</primary><secondary>missing</secondary></indexterm>

			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="java_access_control_exception">
				<para>
					Why do I get a <literal>java.security.AccessControlException</literal> exception
					access denied?
				</para>
			</question>

			<answer>
				<para>
					If you do not properly set permissions when launching code
					using ProActive, you may get the following exception or a similar
					one.</para>

				<screen>java.security.AccessControlException: access denied (java.net.SocketPermission 127.0.0.1:1099 connect,resolve)
	at java.security.AccessControlContext.checkPermission(AccessControlContext.java:270)
	at java.security.AccessController.checkPermission(AccessController.java:401)
	at java.lang.SecurityManager.checkPermission(SecurityManager.java:542)
	at java.lang.SecurityManager.checkConnect(SecurityManager.java:1044)
	at java.net.Socket.connect(Socket.java:419)
	at java.net.Socket.connect(Socket.java:375)
	at java.net.Socket.&lt;init&gt;(Socket.java:290)
	at java.net.Socket.&lt;init&gt;(Socket.java:118)
	at sun.rmi.transport.proxy.RMIDirectSocketFactory.createSocket(RMIDirectSocketFactory.java:22)
	at sun.rmi.transport.proxy.RMIMasterSocketFactory.createSocket(RMIMasterSocketFactory.java:122)
	at sun.rmi.transport.tcp.TCPEndpoint.newSocket(TCPEndpoint.java:562)
	at sun.rmi.transport.tcp.TCPChannel.createConnection(TCPChannel.java:185)
	at sun.rmi.transport.tcp.TCPChannel.newConnection(TCPChannel.java:171)
	at sun.rmi.server.UnicastRef.newCall(UnicastRef.java:313)
	at sun.rmi.registry.RegistryImpl_Stub.lookup(Unknown Source)
	at org.objectweb.proactive.core.rmi.RegistryHelper.detectRegistry(RegistryHelper.java:101)
	at org.objectweb.proactive.core.rmi.RegistryHelper.getOrCreateRegistry(RegistryHelper.java:114)
	at org.objectweb.proactive.core.rmi.RegistryHelper.initializeRegistry(RegistryHelper.java:77)
	at org.objectweb.proactive.core.node.rmi.RemoteNodeFactory(RemoteNodeFactory.java:56)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:274)
	at java.lang.Class.newInstance0(Class.java:296)
	at java.lang.Class.newInstance(Class.java:249)
	at org.objectweb.proactive.core.node.NodeFactory.createNodeFactory(NodeFactory.java:281)
	at org.objectweb.proactive.core.node.NodeFactory.createNodeFactory(NodeFactory.java:298)
	at org.objectweb.proactive.core.node.NodeFactory.getFactory(NodeFactory.java:308)
	at org.objectweb.proactive.core.node.NodeFactory.createNode(NodeFactory.java:179)
	at org.objectweb.proactive.core.node.NodeFactory.createNode(NodeFactory.java:158)
	...</screen>

				<para>
					ProActive uses
					<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://java.sun.com/products/jdk/rmi/">RMI</link> as its
					underlying transport technology. It uses code downloading
					features to automatically move generated stub classes from one JVM
					to another one. For that reason, ProActive needs to install a
					<literal>SecurityManager</literal> that controls the execution of
					the Java code based on a set of permissions given to the JVM.
					Without explicit permissions nothing is granted for the code running
					outside <literal>java.*</literal> or <literal>sun.*</literal>
					packages.
				</para>

				<para>
					See Permissions on
					<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://java.sun.com/j2se/1.3/docs/guide/security/permissions.html">JavaTM
					2 SDK</link> to learn more about Java permissions.
				</para>

				<para>
					As a first approximation, in order to run your code, you can
					create a simple policy file granting all permissions for all
					code:
				</para>

				<screen>grant { permission java.security.AllPermission; };</screen>

				<para>
					Then, you need to start your Java program using the property
					<literal>-Djava.security.policy</literal>. For instance:
				</para>

				<screen> java -Djava.security.policy=my.policy.file MyMainClass </screen>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="connection_refused_by_127">
				<para>Why do I get a <literal>java.rmi.ConnectException: Connection refused to host: 127.0.0.1</literal> ?</para>
			</question>

			<answer>
				<para>
					Sometimes, the hosts files (<literal>/etc/hosts</literal> for UNIX)
					contains <literal>127.0.0.1</literal> along with the name of the machine.
					This is an issue for ProActive and JAVA network connections in general. To get round
					the problem, start your programs with the command line argument:
					<screen>-Dsun.net.spi.nameservice.provider.1=dns,sun"</screen>.
					This tells java not to look at the hosts file, but rather to ask
					the DNS for network information.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="object_properties_not_updated">
				<para>Why aren't my object's fields updated?</para>
			</question>

			<answer>
				<para>
					Suppose you have a class <literal>A</literal> with a
					field <literal>a1</literal> as the example below.
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/faq_3.snip"/></textobject></programlisting>

				<para>
					When you reference an active object, you always reference it
					through its associated stub
					(see <xref linkend="ActiveObjectCreation_html_elementRole"/> for the definition of Stub).
					The stub class inheriting from the reified class, it
					has also all its fields. But those fields are totally
					useless as the only role of the generated stub is to reify every
					public methods call into a request passed to the associated proxy.
					Therefore accessing directly the fields of an active object
					through its active reference would result in accessing the
					fields of the generated stub. This is certainly not the behavior
					one would expect.
				</para>

				<para>
					The solution to this problem is very simple:
					<emphasis role="bold">active object fields should only be accessed through a
					public method (getter and setter) </emphasis>. Otherwise, you are accessing the local
					Stub's fields.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="references_to_an_active_object">
				<para>
					How can I pass a reference on an active object? What is the
					difference between <literal>this</literal> and
					<literal>PAActiveObject.getStubOnThis()</literal>?
				</para>
			</question>

			<answer>
				<para>
					Suppose you have a class <literal>A</literal> that you want to
					make active. In <literal>A</literal>, you want to have a method that
					returns a reference on that instance of <literal>A</literal> as the
					example below.
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/faq_4.snip"/></textobject></programlisting>

				<para>
					There is indeed a problem in the code above. If an instance of
					<literal>A</literal> is created as, or turned into, an active object,
					the method <literal>getRef</literal> will in fact be called through
					the <emphasis role="bold">Body</emphasis> of the active object by
					its active thread. The value returned by the method will be the
					direct reference on the reified object and not a reference on the
					active object. If the call is issued from another JVM, the value
					will be passed by copy and the result (assuming <literal>A</literal> is serializable)
					will be a deep copy of <literal>A</literal> with no links to the active object.
				</para>

				<para>
					The solution, if you want to pass a link to the active object
					from the code of the reified object, is to use the method
					<literal>PAActiveObject.getStubOnThis()</literal>. This method will
					return the reference to the stub associated to the active object
					whose thread is calling the method. The correct version of the
					previous class is:
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/faq_5.snip"/></textobject></programlisting>
			</answer>
		</qandaentry>


		<qandaentry>
			<question xml:id="ao_how_to_create">
				<para>How can I create an active object?</para>
			</question>

			<answer>
				<para>
					To create an active object, you can invoke one of the methods
					<literal>newActive</literal> or <literal>turnActive</literal> of the
					<literal>ProActive</literal> class.
					<literal>PAActiveObject.newActive</literal> creates an active object
					based on the instantiation of a new object whereas
					<literal>PAActiveObject.turnActive</literal> creates an active object
					based on an existing object. Both of the
					<literal>newActive</literal> or <literal>turnActive</literal>
					methods allow you to specify where to create the active object
					(which node) and to customize its activity or its body (see
					<xref linkend="instantion_based_and_object_based_creation"/>).
				</para>

				<para>
					Here is a simple example creating an active object of class
					<literal>A</literal> in the local JVM. If the invocation of the
					constructor of class <literal>A</literal> throws an exception, it is
					placed inside an exception of type
					<literal>ActiveObjectCreationException</literal>. When the call to
					<literal>newActive</literal> returns, the active object has been
					created and its active thread is started.
				</para>
				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/faq_6.snip"/></textobject></programlisting>

			</answer>
		</qandaentry>


		<qandaentry>
			<question xml:id="instantion_based_and_object_based_creation">
				<para>
					What are the differences between instantiation based and
					object based active objects creation?
				</para>
			</question>

			<answer>
				<para>
					In <emphasis role="bold">ProActive</emphasis>, there are two
					ways to create active objects. One way is to use
					<literal>PAActiveObject.newActive</literal> and is based on the
					instantiation of a new object, the other is to use
					<literal>PAActiveObject.turnActive</literal> and is based on the use of
					an existing object.
				</para>

				<para>
					When using instantiation based creation, any argument passed
					to the constructor of the reified object through
					<literal>PAActiveObject.newActive</literal> is serialized and passed by
					copy to the object. This is because the model behind
					<emphasis role="bold">ProActive</emphasis> is uniform whether the active
					object is instantiated locally or remotely. The parameters are
					therefore guaranteed to be passed by copy to the constructor. When
					using <literal>PAActiveObject.newActive</literal>, you have to make sure that
					the arguments of the constructor are
					<literal>Serializable</literal>. On the other hand, the class used
					to create the active object <emphasis role="bold">does not need to
					be</emphasis><literal>Serializable</literal> even in case the
					active object is created remotely.</para>

					<para>When using object based creation, you create the object that
					is going to be reified as an active object before hand. Therefore
					there is no serialization involved when you create the object. When
					you invoke <literal>PAActiveObject.turnActive</literal> on the object two
					cases are possible. If you create the active object locally (on a
					local node), it will not be serialized. If you create the active
					object remotely (on a remote node), the reified object will be
					serialized. Therefore, if the <literal>turnActive</literal> is done
					on a remote node, the class used to create the active object
					<emphasis role="bold">has to
					be</emphasis><literal>Serializable</literal>. In addition, when
					using <literal>turnActive</literal>, care must be taken that no
					other references to the originating object are kept by other objects
					after the call to turnActive. A direct call to a method of the
					originating object without passing by a ProActive stub on this
					object will break the model.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="why_nooargs">
				<para>Why do I have to write a no-args constructor?</para>
			</question>

			<answer>
				<para>
					<emphasis role="bold">ProActive</emphasis> automatically
					creates a stub/proxy pair for your active objects.
					A constructor with no-args needs to be used for active object
					creation since the constructor is called for the stub creation.
					Avoid placing initialization code in this constructor, as it may lead to unexpected
					behavior.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="how_to_control_ao_activity">
				<para>
					How do I control the activity of an active
					object?
				</para>
			</question>

			<answer>

				<para>
					As explained in <xref linkend="ActiveObjectCreationWithCustomActivity"/>,
					there are two ways to define the activity of your active object
				</para>

				<itemizedlist>
					<listitem>
						<para>
							Implementing one or more of the sub-interfaces of
							<literal>Active</literal> directly in the class used to create
							the active object
						</para>
					</listitem>

					<listitem>
						<para>
							Passing an object implementing one or more of the
							sub-interfaces of <literal>Active</literal> in parameter to the
							method <literal>newActive</literal> or
							<literal>turnActive</literal>
						</para>
					</listitem>
				</itemizedlist>

				<para>
					<emphasis role="bold">
						Implementing the interfaces
						directly in the class used to create the active
						object
					</emphasis>
				</para>

				<para>
					This is the easiest solution when you do control the class
					that you make active. Depending on which phase in the life of the
					active object you want to customize, you implement the corresponding
					interface (one or more) amongst <literal>InitActive</literal>,
					<literal>RunActive</literal> and <literal>EndActive</literal>. Here
					is an example that has a custom initialization and activity.
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/faq_7.snip"/></textobject></programlisting>

				<para>
					<emphasis role="bold">
						Passing an object
						implementing the interfaces when creating the active
						object
					</emphasis>
				</para>

				<para>
					This is the solution to use when you do not control the class
					that you make active or when you want to write generic activity
					policy and reused them with several active objects. Depending on
					which phase in the life of the active object you want to customize,
					you implement the corresponding interface (one or more) amongst
					<literal>InitActive</literal>, <literal>RunActive</literal> and
					<literal>EndActive</literal>. Here is an example that has a custom
					activity.
				</para>

				<para>
					Compared to the solution above where interfaces are directly
					implemented in the reified class, there is one restriction here: you
					cannot access the internal state of the reified object. Using an
					external object should therefore be used when the implementation of
					the activity is generic enough not to have to access the member
					variables of the reified object.
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/faq_8.snip"/></textobject></programlisting>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="what_happened_to_live">
				<para>
					What happened to the former live() method and Active
					interface?
				</para>
			</question>

			<answer>
				<para>
					The former <literal>Active</literal> interface was simply a
					marker interface allowing to change the body and/or the proxy of an
					active object. It was useless most of the time and was made
					obsolete with the introduction of the MetaObjectFactory
					in the <emphasis role="bold">0.9.3</emphasis> release.
				</para>
				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/metaobjectfactory.snip"/></textobject></programlisting>

				<para>
					Up to <emphasis role="bold">ProActive 0.9.3</emphasis>, the
					activity of an active object was given by a method
					<literal>live(Body)</literal> called by reflection of the reified
					object. Doing this way did not allow compile time type checking of
					the method, did not allow to externalize from
					the reified object its activity and did not allow to give a custom
					activity to an active object created using
					<literal>turnActive</literal>. We solved all those issues using
					the new mechanism based on the three interfaces
					<literal>InitActive</literal>, <literal>RunActive</literal> and
					<literal>EndActive</literal>.
				</para>

				<para>
					In order to convert the code of an active object containing a
					method <literal>live</literal> to the new interface you just need
					to:
				</para>

				<itemizedlist>
					<listitem>
						<para>
							implement the new interface <literal>RunActive</literal>
							(and remove <literal>Active</literal> if it was
							implemented)
						</para>
					</listitem>

					<listitem>
						<para>
							changed the name of the method <literal>live</literal> to
							<literal>runActivity</literal>
						</para>
					</listitem>
				</itemizedlist>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="why_avoid_returning_null">
				<para>Why should I avoid to return null in methods body?</para>
			</question>

			<answer>
				<para>
					On the <emphasis role="bold">caller</emphasis> side, the test:
					<programlisting language="java">if (result_from_method == null)</programlisting>
					has no sense. Indeed, result_from_method is a couple Stub-FutureProxy as
					explained above, so even if the method returns null,
					result_from_method cannot be null:
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/faq_9.snip"/></textobject></programlisting>

				<para>On the caller side:</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/faq_10.snip"/></textobject></programlisting>

				<para>
					This test is never true. Indeed, result_from_method is
					either <emphasis role="bold">Stub--&gt;Proxy--&gt;null</emphasis> if the
					future is not yet available or if the method returns null, or it is
					<emphasis role="bold">Stub--&gt;Proxy--&gt;Object</emphasis> if the future is
					available, but result_from_method is <emphasis role="bold">never
					null</emphasis>. See Documentation on Futures in <xref linkend="FutureObjectCreation_commonerror"/>
					for more information about common errors to
					avoid.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="component_out_of_ao">
				<para>
					How do I make a Component version out of an Active Object
					version?
				</para>
			</question>

			<answer>
				<para>
					There is such an example, in the <literal>ProActive/examples/components/c3d</literal>
					directory. The code for c3d is adapted to use components.
				</para>

				<para>There are several steps to cover:</para>

				<orderedlist>
					<listitem>
						<para>
							Make sure you have made interfaces for the objects which
							are to be turned into components. This is needed to be able to do the
							binding between components.
						</para>
					</listitem>

					<listitem>
						<para>
							Replace the references to Active Object classes by their
							interfaces.
						</para>
					</listitem>

					<listitem>
						<para>
							Create a component wrapper for each Active Object which
							should appear as a component. It should contain the binding
							behavior (bindFc,unbindFc,listFc,lookupFc methods), and maybe
							handle field modification.
						</para>
					</listitem>

					<listitem>
						<para>
							Create a main class where the components are created then
							bound, or use an ADL file to do so.
						</para>
					</listitem>
				</orderedlist>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="why_not_asynch">
				<para>Why is my call not asynchronous?</para>
			</question>

			<answer>
				<para>
					ProActive allows to have asynchronous code,
					in the following cases:
				</para>

				<itemizedlist>
					<listitem>
						<para>
							The return value is reifiable (see <xref linkend="reifiableDefinition"/>).
							This is needed to ensure the creation of the Future, which is the returned container
							(the future is used while waiting for the effective result to arrive).
							The returned class has to be Serializable, can not be final, and must have an empty
							no-arguments constructor.
						</para>
					</listitem>

					<listitem>
						<para>
							The return value is void. In this case, the rendezvous is made, and
							then the caller resumes its activity, while the receiver has now a new <literal>methodCall</literal>
							in its queue.
						</para>
					</listitem>

				</itemizedlist>

				<para>More explanations can be found in <xref linkend="FutureObjectCreation"/>.</para>

			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="difference_between_params_in_dd_and_pa_config">
				<para>
					What is the difference between passing parameters in
					deployment descriptors and setting properties in ProActive
					Configuration file?
				</para>
			</question>

			<answer>
				<para>
					Parameters defined in deployment descriptor should be only JVM
					related, whereas properties set in the configuration file are
					ProActive properties or user-defined properties. They are used with
					a different approach: parameters given in descriptors are part of
					the java command that will create other JVMs, whereas properties
					will be loaded once JVMs are created.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="slow_startup">
				<para>
					Why ProActive is slow to start ?
				</para>
			</question>

			<answer>
				<para>
					Since ProActive Programming 4.1.0, an embedded Jetty HTTP server is started. By default, Jetty
					uses the <varname>java.security.SecureRandom</varname> random number generator. It uses the operating system's
					source to provide entropy. If your machine is very calm, then there may not be enough
					entropy to drive the random number generator and hence the operating system waits for more
					interrupts, disk IO, network traffic or whatever is used to generate the entropy.
				</para>

				<para>
					See the
					<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.codehaus.org/display/JETTY/Connectors+slow+to+startup">
					Jetty documentation</link> for more details.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question>
				<para>
					Why do I see <quote>The ProActive log4j collector is still not available, printing logging events on the console to avoid log loss</quote>
					when a ProActive runtime is started ?
				</para>
			</question>
			<answer>
				<para>
					Since ProActive Programming 4.1.0, a distributed log4j mechanism is enabled by default when an
					application is started with the GCM deployment framework (see <xref linkend="configuration_log4j"/>).
				</para>

				<para>
					This mechanism expects to be able to contact a log collector located on the machine who loaded
					the GCM Application Descriptor. If a started ProActive runtime is not able to contact the
					log collector within 30 seconds then all the logging events are printed on the standard output
					to avoid data loss and help the troubleshooting. As soon as the log collector is
					available all the printed logging entries are sent to the log collector.
				</para>

				<para>
					<xref linkend="slow_startup"/> can cause a such message.
				</para>
			</answer>
		</qandaentry>

		<qandaentry>
			<question xml:id="declaration_error_message">
				<para>
					About the former deployment process: why do I get the following message when parsing my XML
					deployment file:
					<literal>ERROR: file:~/ProActive/descriptor.xml Line:2
					Message:cvc-elt.1: Cannot find the declaration of element
					'ProActiveDescriptor'</literal>?
				</para>
			</question>

			<answer>
				<para>
					This message turns up because the Schema cannot be found.
					Indeed, at the beginning of our XML deployment files, we put the
					line:</para>

					<screen>&lt;ProActiveDescriptor xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
					xsi:noNamespaceSchemaLocation='DescriptorSchema.xsd'&gt;</screen>

					<para>which means, the schema named DescriptorSchema.xsd is expected
					to be found in the current directory to validate the XML. Be sure
					you have this file in the same directory than your file, or just change
					the path to point to the correct schema.</para>
					</answer>
					</qandaentry>
		</qandadiv>
	</qandaset>

</appendix>
