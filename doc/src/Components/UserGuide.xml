<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
	xml:id="ComponentsUserGuide">
	<info><title xml:id="Userguide_53">User guide</title></info>

	<para>
		This chapter explains the specific features and functionalities
		of the GCM Implementation.
	</para>

	<section xml:id="ArchitectureDescriptionLanguage_53"><info><title>Architecture Description Language</title></info>

		<indexterm significance="preferred">
			<primary>ADL</primary>
			<secondary>definition</secondary>
		</indexterm>

		<para/>

		<para>
			The Architecture Description Languages (ADL) are a way to
			describe software and/or system architectures. ADLs
			facilitate application description without concern for the
			underlying implementation code and foster code reuse as an
			effect of decoupling the implementation from the
			architecture. Architectures created by using ADLs are
			composed of predefined entities with various connectors
			that communicate through defined connections. To define an
			architecture through an ADL, we can use a textual syntax
			and/or a graphical syntax, possibly associated with a
			design tool.
		</para>

		<para>
			This GCM implementation reuses and extends the Fractal ADL
			Project.
			For detailed information on Fractal ADL, read
			<link xmlns:xlink="http://www.w3.org/1999/xlink"
				xlink:href="http://fractal.objectweb.org/tutorials/adl/index.html">
				the Fractal ADL tutorial
			</link>.
			This mechanism is used to configure and deploy component
			systems through normalized XML files. Thanks to a specific
			XML DTD, it specifies a definition for each component of
			the application. For instance, it usually describes
			component interfaces, component bindings, component
			attributes, the subcomponents in the case of a composite
			component, the virtual node where the component will be
			deployed, and so on. As it is an extension of the standard
			Fractal ADL, GCM allows reusing and integrating
			ProActive-specific features such as distributed deployment
			using deployment descriptors, active objects, virtual nodes,
			etc. For example, in the case of virtual nodes the
			components ADL has to be associated with a deployment
			descriptor (this is done at parsing time: both files are
			given to the parser).
		</para>

		<section xml:id="Overview_500"><info><title>Overview</title></info>

			<para>
				Components are defined in
				<emphasis role="bold">definition</emphasis>
				files with the .fractal extension. Here is a simple
				example of an ADL
				file extract from the example
				<literal>Helloworld</literal> available in the
				<literal>Examples/org/objectweb/proactive/examples/components/helloworld</literal>
				directory:
			</para>

			<programlisting language="xml" linenumbering="numbered"><textobject><textdata fileref="automatic_snippets/component_userguide_1.snip"/></textobject></programlisting>

			<para>
				Now, here is a detailed description of each lines:
				<itemizedlist>
					<listitem>
						<para>1: Classical prologue of XML files.</para>
					</listitem>
					<listitem>
						<para>
							2: The syntax of the document is validated
							against a DTD retrieved from the classpath attribute.
						</para>
					</listitem>
					<listitem>
						<para>
							4: The
							<emphasis role="bold">definition</emphasis>
							element has a name (which has to be the same
							name that the file's without its extension). Inheritance is
							supported through the 'extends' attribute.
						</para>
					</listitem>
					<listitem>
						<para>
							5: The
							<emphasis role="bold">interface</emphasis>
							element allows to specify interfaces of the
							current enclosing component.
						</para>
					</listitem>
					<listitem>
						<para>
							7-16: Nesting is allowed for composite
							components and is done by adding other
							<emphasis role="bold">component</emphasis>
							elements. Components can be specified and
							created in this definition, and these
							components can themselves be defined here or
							in other definition files.
						</para>
					</listitem>
					<listitem>
						<para>
							10: Primitive components specify the
							<emphasis role="bold">content</emphasis>
							element, which indicates the implementation
							class containing the business logic for this
							component.
						</para>
					</listitem>
					<listitem>
						<para>
							11-14: Components can specify a
							<emphasis role="bold">attributes</emphasis>
							element, which allows to initialize
							attributes of a component.
						</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Binding</primary>
							<secondary>adl</secondary>
						</indexterm>
						<para>
							18-19: The
							<emphasis role="bold">binding</emphasis>
							element specifies bindings between
							interfaces of components and specifying
							'this' as the name of the component refers
							to the current enclosing component.
						</para>
					</listitem>
					<listitem>
						<para>
							21: The
							<emphasis role="bold">controller</emphasis>
							elements can have the following 'desc'
							values: 'primitive' or 'composite'.
						</para>
					</listitem>
					<listitem>
						<para>
							23: The
							<emphasis role="bold">
								virtual-node
							</emphasis>
							element offers distributed deployment
							information. It can be exported and composed
							in the exported VirtualNodes element.
						</para>
						<para>
							The component will be instantiated on the
							specified virtual node (or the one that is
							exported). If there are several nodes mapped
							on the virtual node, the component will be
							instantiated on one of the nodes of the
							virtual node.
						</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>
				The syntax is similar to the standard Fractal ADL and
				the parsing engine has been extended. Features specific
				to ProActive are:
			</para>

			<itemizedlist>
				<listitem>
					<para>
						Virtual nodes can be
						<emphasis role="bold">exported</emphasis>
						and
						<emphasis role="bold">composed</emphasis>.
					</para>
				</listitem>
				<listitem>
					<para>Template components are not handled.</para>
				</listitem>
				<listitem>
					<para>
						The validating DTD has to be specified as
						<literal>classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd</literal>
					</para>
				</listitem>
			</itemizedlist>

		</section>

		<section xml:id="Exportationandcompositionofvirtualnodes"><info><title>Exportation and composition of virtual nodes</title></info>

			<para>
				Components are deployed on the virtual node that is
				specified in their definition. It has to appear in the
				deployment descriptor
				<emphasis role="bold">unless</emphasis>
				this virtual node is exported. In this case, the name of
				the exported virtual node should appear in the
				deployment descriptor, unless this exported virtual node
				is itself exported.
			</para>

			<para>
				When exported, a virtual node can take part in the
				composition of other exported virtual nodes. The idea is
				to further extend reusability of existing (and packaged,
				packaging being a forthcoming feature of Fractal)
				components.
			</para>

			<para>
				This is particularly useful when you want to use a component
				created by someone else. The programmer who implemented this
				component may used his own virtual node that you cannot use.
				Exporting his virtual node, the programmer enables you to
				redefine this virtual node and thus, you can deploy the
				component on every virtual node you want. You can also make
				composition of virtual nodes deterring you from bothering with
				the definition (in your deployment descriptor) of many virtual
				nodes. Moreover, a composition of exported virtual nodes also
				enables to gather two or several components on a same virtual
				node. This is an essential aspect which provides you with a
				means to overcome latency bottlenecks when a lot of
				communications is needed between several components.
			</para>

			<para>
				In the example, the component defined in
				helloworld-distributed-wrappers.fractal exports the
				virtual nodes VN1 and VN2:
			</para>

			<programlisting language="xml"><textobject><textdata fileref="automatic_snippets/exported_virtual_node_1.snip"/></textobject></programlisting>

			<para>
				VN1 is composed of the exported virtual node
				'client-node' from the component named client
			</para>

			<para>
				In the definition of the client component
				(ClientImpl.fractal), we can see that client-node is an
				exportation of a virtual node which is also name
				'client-node':
			</para>

			<programlisting language="xml"><textobject><textdata fileref="automatic_snippets/exported_virtual_node_2.snip"/></textobject></programlisting>

			<para>
				Although this is a simplistic example, one should
				foresee a situation where ClientImpl would be a
				prepackaged component, where its ADL could not be
				modified. The exportation and composition of virtual
				nodes allow to adapt the deployment of the system
				depending on the existing infrastructure. Collocation can
				be specified in the enclosing component definition
				(helloworld-distributed-wrappers.fractal):
			</para>

			<programlisting language="xml"><textobject><textdata fileref="automatic_snippets/exported_virtual_node_3.snip"/></textobject></programlisting>

			<para>
				As a result, the client and server component will be
				collocated / deployed on the same virtual node. This can
				be profitable if there is a lot of communications
				between these two components.
			</para>

			<para>
				When specifying 'null' as the name of an exported
				virtual node, the components will be deployed on the
				current virtual machine (helloworld-local-no-wrappers).
				This can be useful for debugging purposes.
			</para>

			<programlisting language="xml"><textobject><textdata fileref="automatic_snippets/exported_virtual_node_4.snip"/></textobject></programlisting>

			<para>
				For more information on exported virtual nodes, please
				refer to
				<citation><xref linkend="M06" endterm="PhD-thesis-Morel.abbrev"/></citation>
			</para>

		</section>

		<section xml:id="adl_usage_userguide"><info><title xml:id="Usage_53">Usage</title></info>

			<para>
				ADL definitions correspond to component factories. ADL
				definition can be used directly:
            <programlisting language="java"><textobject><textdata fileref="automatic_snippets/programing_with_components_1.snip"/></textobject></programlisting>
			</para>

			<para>
				It is also possible to use the launcher tool, which
				parses the ADL, creates a corresponding component
				factory, instantiates and assembles the components
				as defined in the ADL. This launcher is defined in the
				<literal>org.objectweb.proactive.core.component.adl.Launcher</literal>
				class and it can be used as follows:
			</para>

			<screen>Launcher [-java|-fractal] &lt;definition&gt; [&lt;itf&gt;] [deployment-descriptor])</screen>

			<para>
				where [-java|-fractal] comes from the Fractal ADL
				Launcher (put -fractal for ProActive/GCM components),
				&lt;definition&gt; is the name of the component to
				be instantiated and started, &lt;itf&gt; is the name
				of its Runnable interface if it has one, and
				&lt;deployment-descriptor&gt; the location of the
				ProActive deployment descriptor to use. It is also
				possible to use this class directly from its static
				main method.
			</para>

		</section>

	</section>

	<section xml:id="ImplementationspecificAPI_53"><info><title>Implementation specific API</title></info>

		<section xml:id="apibootstrapcomponent_53"><info><title>API and bootstrap component</title></info>

			<para>
				The API is the same as for any Fractal implementation,
				though some classes are GCM-specific or
				implementation-specific.
			</para>

			<para>
				Thus to get the bootstrap component, there are three
				possibilities:
				<itemizedlist>
					<listitem>
						<para>
							Use the standard Fractal API with one of
							the methods
							<literal>org.objectweb.fractal.util.Fractal#getBootstrapComponent(...)</literal>.
							In that case, the
							<literal>fractal.provider</literal> system
							property has to be set.
						</para>
					</listitem>
					<listitem>
						<para>
							Use the standard GCM API with one of the
							methods
							<literal>org.etsi.uri.gcm.util.GCM#getBootstrapComponent(...)</literal>.
							In that case, the
							<literal>gcm.provider</literal> system
							property has to be set.
						</para>
					</listitem>
					<listitem>
						<para>
							Use the ProActive/GCM API with one of the
							methods
							<literal>org.objectweb.proactive.core.component.Utils#getBootstrapComponent(...)</literal>.
							In that case, the system property to be
							set can be either
							<literal>gcm.provider</literal> or
							<literal>fractal.provider</literal>.
							This last solution is the one used in all
							examples and tests provided through
							ProActive.
					</para>
					</listitem>
				</itemizedlist>
				In all cases, for this implementation the used system
				property has to be set to
				<literal>org.objectweb.proactive.core.component.Fractive</literal>.
			</para>

			<para>
				The
				<literal>org.objectweb.proactive.core.component.Utils</literal>
				class also contains several useful methods to
				handle components. Moreover, as for any Fractal
				or GCM implementation, ProActive/GCM also
				supports the use of other methods of the
				<literal>org.objectweb.fractal.util.Fractal</literal>
				and
				<literal>org.etsi.uri.gcm.util.GCM</literal>
				classes.
			</para>

		</section>

		<section xml:id="Requirements_53"><info><title>Requirements</title></info>

			<para>
				As this implementation is based on ProActive, several
				conditions are required (more in
				<link xlink:href="../../ReferenceManual/multiple_html/ActiveObjectCreation.html#ActiveObjectCreation">Chapter 2. Active Objects: Creation And Advanced Concepts</link>):
			</para>

			<itemizedlist>
				<listitem>
					<para>
						The base class for the implementation of a
						primitive component has to provide a no-argument
						and preferably an empty constructor.
					</para>
				</listitem>

				<listitem>
					<para>
						Asynchronous method calls with transparent
						futures is a core feature of ProActive
						<link xlink:href="../../ReferenceManual/multiple_html/ActiveObjectCreation.html#FutureObjectCreation">Chapter 2.7. Asynchronous calls and futures</link>)
						 and it allows concurrent processing. Indeed,
						suppose a caller invokes a method on a callee.
						This method returns a result on a component.
						With synchronous method calls, the flow of
						execution of the caller is blocked until the
						result of the called method is received. In the
						case of intensive computations, this can be
						relatively long. With asynchronous method calls,
						the caller gets a future object and will
						continue its tasks until it really uses the
						result of the method call. The process is then
						blocked (it is called wait-by-necessity) until
						the result has effectively been calculated.
					</para>
					<para>
						Thus, for asynchronous invocations, return types
						of the methods provided by the interfaces of the
						components have to be reifiable (Non-final and
						serializable class) and methods must not throw
						exceptions.
					</para>
				</listitem>
			</itemizedlist>

		</section>

		<section xml:id="Contentandcontrollerdescriptions_53"><info><title>Content and controller descriptions</title></info>

			<para>
				When a component is instantiated with the
				<literal>newFcInstance(Type type, Object controllerDesc, Object contentDesc)</literal>
				method of the
				<literal>org.objectweb.fractal.api.factory.Factory</literal>
				class, in addition to the type of the component have to
				be specified the controller description and the content
				description of the component.
			</para>

			<para>
				The controller description (
				<literal>
					org.objectweb.proactive.core.component.ControllerDescription
				</literal>
				) is useful to describe the controllers of components.
				It allows to define:
				<itemizedlist>
					<listitem>
						<para>the name of a component.</para>
					</listitem>
					<listitem>
						<para>the hierarchical type of a component.</para>
					</listitem>
					<listitem>
						<para>
							the custom controllers for a component. The
							configuration of the controllers is
							described in a properties file whose
							location can be given as a parameter. The
							controllers configuration file is simple: it
							associates the signature of a controller
							interface with the implementation that has
							to be used. During the construction of the
							component, the membrane is automatically
							constructed with these controllers. The
							controllers are linked together and
							requests targeting a control interface
							visit the different controllers until they
							find the suitable one. Then, the
							request is executed on this controller.
						</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>
				The role of the content description
				(<literal>
					org.objectweb.proactive.core.component.ContentDescription
				</literal>)
				is to define some information about a component:
				<itemizedlist>
					<listitem>
						<para>
							the classname of the component (the only one
							information mandatory).
						</para>
					</listitem>
					<listitem>
						<para>
							the constructor parameters of the component
							(optional).
						</para>
					</listitem>
					<listitem>
						<para>
							the activity as defined in the ProActive
							model (optional). See
							<link xlink:href="../../ReferenceManual/multiple_html/ActiveObjectCreation.html#ActiveObjectCreation">Chapter 2. Active Objects: Creation And Advanced Concepts</link>
							for more information about activity in
							ProActive.
						</para>
					</listitem>
					<listitem>
						<para>
							the meta-object factory for the component
							(optional).
						</para>
					</listitem>
				</itemizedlist>
			</para>

		</section>

		<section xml:id="Collectiveinterfaces_1"><info><title>Collective interfaces</title></info>

			<para>
				Collective interactions are a GCM extension to the
				Fractal model, described in section
				<xref linkend="collective-interfaces"/>,
				that relies on collective interfaces.
			</para>

			<para>
				This feature provides collective interactions (1-to-n
				and n-to-1 interactions between components), namely
				multicast and gathercast interfaces
			</para>

		</section>

		<section xml:id="Monitorcontroller_53"><info><title>Monitor controller</title></info>

			<para>
				By using the
				<literal>org.etsi.uri.gcm.api.control.MonitorController</literal>
				controller, users can retrieve various statistics on
				components such as the average length of the queue of
				a given method or the last execution time of another
				method. Thus, with these metrics, users can be
				informed on the QoS (Quality of Service) and then
				decide to do some changes in their application to
				improve its performance.
			</para>

			<para>
				After having started the monitoring (Method
				<literal>startGCMMonitoring()</literal>), for each
				methods exposed by the server interfaces of a
				component this controller will be able to provide an
				instance of
				<literal>org.objectweb.proactive.core.component.control.MethodStatistics</literal>,
				which itself provides some statistics related to the
				method.
			</para>

			<para>
				The set of statistics that can be retrieved and the
				corresponding methods to call are described through
				the <literal>MethodStatistics</literal> interface:
				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/methodstatistics.snip"/></textobject></programlisting>
				In regard to the <literal>MethodStatistics</literal>
				instances, they can be recovered by the following
				<literal>MonitorController</literal>'s methods:
			</para>

			<itemizedlist>
					<listitem>
						<para>
							<programlisting language="java">public Map&lt;String, Object&gt; getAllGCMStatistics();</programlisting>
							Which returns the statistics of each
							methods of each server interfaces of
							the monitored component through a
							<literal>Map</literal> where values
							are objects which can be cast to
							<literal>MethodStatistics</literal>.
							The key to obtain the
							<literal>MethodStatistics</literal>
							corresponding to a method can be
							generated thanks to the method
							<literal>org.objectweb.proactive.core.component.control.MonitorControllerHelper#generateKey()</literal>
							which takes as parameters the
							interface name, the method name and an
							array of parameter types of the method.
						</para>
					</listitem>

					<listitem>
						<para>
							<programlisting language="java">public Object getGCMStatistics(String itfName, String methodName, Class&lt;?&gt;[] parametersTypes)</programlisting>
							Which returns an object which can be
							cast to
							<literal>MethodStatistics</literal> and
							corresponds to the statistics of the
							method methodName which takes as
							parameters the given parameter types
							and belongs to the interface itfName.
						</para>
					</listitem>
				</itemizedlist>

				<para>
					These methods to retrieve
					<literal>MethodStatistics</literal> are in
					"immediate services", i.e. when calling one of
					these methods, the corresponding request will
					not be enqueued in the component queue as any
					other request but it will be executed immediately
					and thus avoiding to spend to much time to get
					statistics.
				</para>

		</section>

		<section xml:id="Prioritycontroller_53"><info><title>Priority controller</title></info>

			<para>
				In order to define non functional prioritized requests
				(useful for instance for life cycle management,
				reconfiguration, ...), a partial order between each kind
				of request is available to specify when an incoming
				request can pass requests already in the queue.
			</para>

			<para>
				Here are the different priorities available for the
				requests:
				<itemizedlist>
					<listitem>
						<para>
							F: Functional request. Always goes at the
							end of the requests queue.
						</para>
					</listitem>
					<listitem>
						<para>
							NF1: Standard Non Functional request. Also
							always goes at the end of the requests
							queue.
						</para>
					</listitem>
					<listitem>
						<para>
							NF2: Non Functional prioritized request.
							Pass the Functional requests into the
							requests queue but respect the order of the
							other Non Functional requests.
						</para>
					</listitem>
					<listitem>
						<para>
							NF3: Non Functional most prioritized
							request. Pass all the other requests into
							the requests queue.
						</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>
				The following picture represents the addition of non
				functional requests depending on their priorities:
			</para>

			<figure xml:id="NF_priority_controller"><info><title>Addition of non functional prioritized request</title></info>
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/NF-priority-controller.png" format="PNG"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				Thus, for prioritize non functional requests, the
				<literal>org.etsi.uri.gcm.api.control.PriorityController</literal>
				controller has to be used:
				<programlisting language="java"><textobject><textdata fileref="code_snippets/PriorityController.java"/></textobject></programlisting>
			</para>

		</section>

		<section xml:id="Streamports_53"><info><title>Stream ports</title></info>

			<para>
				Stream ports allow to ensure to have component interfaces
				which only have one way communication methods (client side
				to server side).
			</para>
			<para>
				Thus, by using the
				<literal>org.objectweb.proactive.core.component.type.StreamInterface</literal>
				interface as a tag on the java interface definition of a
				component interface, the GCM implementation will check
				during the instantiation of an Interface Type created with
				the <literal>createFcItfType()</literal> or
				<literal>createGCMItfType()</literal> methods, if all the
				methods of the given interface, and its parents, return void.
				If not, an
				<literal>org.objectweb.fractal.api.factory.InstantiationException</literal>
				exception is thrown accordingly to the Fractal specifications.
			</para>

		</section>

	</section>

	<section xml:id="collective-interfaces"><info><title>Collective interfaces</title></info>

		<para>
			In this chapter, we consider multiway communications -
			communications to or from several interfaces - and notably
			parallel communications, which are common in Grid computing.
		</para>
		<para>
			The objective is to simplify the design of distributed Grid
			applications with multiway interactions.
		</para>
		<para>
			The driving idea is to manage the semantics and behavior of
			collective communications at the interface level.
		</para>

		<section xml:id="Motivations_53"><info><title>Motivations</title></info>

			<para>
				Grid computing uses the resources of many separate
				computers connected by a network (usually the Internet)
				to solve large-scale computation problems. Because of
				the number of available computers, it is fundamental to
				provide tools for facilitating communications to and
				from these computers. Moreover, Grids may contain
				clusters of computers, where local parallel computations
				can be very efficiently performed (this is part of the
				solution for solving large-scale computation problems)
				which means that programming models for Grid computing
				should include parallel programming facilities. We
				address this issue, in the context of a component model
				for Grid computing, by introducing
				<emphasis role="bold">collective interfaces</emphasis>.
			</para>

			<para>
				The component model that we use (Fractal) proposes two
				kinds of cardinalities for interfaces,
				<emphasis>singleton</emphasis>
				or
				<emphasis>collection</emphasis>,
				which result in one-to-one bindings between client and
				server interfaces. It is possible though to introduce
				binding components, which act as brokers and may handle
				different communication paradigms. Using these
				intermediate binding components, it is therefore
				possible to achieve one-to-n, n-to-one or n-to-n
				communications between components. It is not possible
				however for an interface to express a collective
				behavior: explicit binding components are needed in this
				case.
			</para>

			<para>
				The GCM proposes the addition of new cardinalities in the
				specification of Fractal interfaces, namely
				<emphasis>multicast</emphasis>
				and
				<emphasis>gathercast</emphasis>.
				Multicast and gathercast interfaces give the
				possibility to
				<emphasis>manage a group of interfaces as a single entity</emphasis>
				(which is not the case with a collection interface,
				where the user can only manipulate individual members of
				the collection), and they
				<emphasis>expose</emphasis>
				the collective nature of a given interface. Moreover,
				specific semantics for multi-way invocations can be
				configured, providing users with flexible communications
				to or from gathercast and multicast interfaces. Lastly,
				avoiding the use of explicit intermediate binding
				components simplifies the programming model and type
				compatibility is automatically verified.
			</para>

			<para>
				The role and use of multicast and gathercast interfaces
				are complementary. Multicast interfaces are used for
				parallel invocations whereas gathercast interfaces are
				used for synchronization and gathering purposes.
			</para>

			<note>
				<para>
					In this implementation of collective interfaces, new
					features of the Java language introduced in Java 5 are
					extensively used, notably annotations and generics.
				</para>
			</note>

		</section>

		<section xml:id="Multicastinterfaces_1"><info><title>Multicast interfaces</title></info>

			<section xml:id="Definition_1"><info><title>Definition</title></info>

				<para>
					<emphasis>
						A multicast interface transforms a single
						invocation into a list of invocations
					</emphasis>
				</para>

				<para>
					A multicast interface is an abstraction for 1-to-n
					communications. When a single invocation is
					transformed into a set of invocations, these
					invocations are forwarded to a set of connected
					server interfaces. A multicast interface is unique
					and it exists at runtime (it is not lazily created).
					The semantics of the propagation of the invocation,
					of the distribution of the invocation parameters
					and of the result (if there is)	are customizable
					(through annotations).
				</para>

				<para>
					Invocations forwarded to the connected server
					interfaces occur in parallel, which is one of the
					main reasons for defining this kind of interface: it
					enables
					<emphasis>
						parallel invocations, with automatic
						distribution of invocation parameters
					</emphasis>.
				</para>

				<para>
					<figure xml:id="multicast_interfaces_for_composite_and_primitive_components"><info><title>Multicast interfaces for primitive and composite components</title></info>
						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/multicast-itfs.png" format="PNG"/>
							</imageobject>
						</mediaobject>
					</figure>
				</para>

			</section>

			<section xml:id="Datadistribution_100"><info><title>Data distribution</title></info>

				<para>
					A multicast invocation leads to the invocation
					services offered by one or several connected server
					interfaces, with possibly distinct parameters for
					each server interface.
				</para>

				<para>
					If some of the parameters of a given method of a
					multicast interface are lists of values, these
					values can be distributed in various ways through
					method invocations to the server interfaces
					connected to the multicast interface. The default
					behavior - namely
					<emphasis>broadcast</emphasis>
					- is to send the same parameters to each of the
					connected server interfaces. In the case where some
					parameters are lists of values, copies of the lists
					are sent to each receiver. However, similar to what
					SPMD programming offers, it may be adequate to strip
					some of the parameters so that the bound components
					will work on different data. In MPI for instance,
					this can be explicitly specified by stripping a data
					buffer and using the
					<emphasis>scatter</emphasis>
					primitive.
				</para>

				<para>
					The following figure illustrates such distribution
					mechanisms: broadcast (a.) and scatter (b.)
				</para>

				<para>
					<figure xml:id="broadcast_and_scatter_of_invocation_parameters"><info><title>Broadcast and scatter of invocation parameters</title></info>
						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/parameters-broadcast-scatter.png" format="PNG"/>
							</imageobject>
						</mediaobject>
					</figure>
				</para>

				<para>
					Invocations occur in parallel and the distribution
					of parameters is automatic.
				</para>
				<section xml:id="Invocationparametersdistributionmodes"><info><title>Invocation parameters distribution modes</title></info>

					<para>
						Five modes of parameter distribution are
						provided by default, defining distribution
						policies for a list of parameters:
					</para>

					<itemizedlist>
						<listitem>
							<para>
								<emphasis role="bold">BROADCAST</emphasis> - copies a list of
								parameters and sends a copy to each
								connected server interface.
								<programlisting language="java">ParamDispatchMode.BROADCAST</programlisting>
							</para>
						</listitem>

						<listitem>
							<para>
								<emphasis role="bold">ONE-TO-ONE</emphasis> - sends the i<superscript>th</superscript>
								parameter to the connected server
								interface of index i. This implies that
								the number of elements in the annotated
								list is equal to the number of connected
								server interfaces.
								<programlisting language="java">ParamDispatchMode.ONE_TO_ONE</programlisting>
							</para>
						</listitem>

						<listitem>
							<para>
								<emphasis role="bold">ROUND-ROBIN</emphasis> - distributes each
								element of the list parameter in a
								round-robin fashion to the connected
								server interfaces.
								<programlisting language="java">ParamDispatchMode.ROUND_ROBIN</programlisting>
							</para>
						</listitem>

						<listitem>
							<para>
								<emphasis role="bold">RANDOM</emphasis> - distributes each element
								of the list parameter in a random manner
								to the connected server interfaces.
								<programlisting language="java">ParamDispatchMode.RANDOM</programlisting>
							</para>
						</listitem>

						<listitem>
							<para>
								<emphasis role="bold">UNICAST</emphasis> - sends only one parameter of the
								list parameters to one of the connected
								server interfaces.
								<programlisting language="java">ParamDispatchMode.UNICAST</programlisting>
							</para>

							<para>
								By default, the behavior is not specified: there
								is no way to predict which parameter will be sent to
								which server interface. Therefore, it is strongly
								recommended to combine the use of the UNICAST parameter
								distribution mode with the dispatch annotation,
								<literal>org.objectweb.proactive.core.group.Dispatch</literal>
								, which allows to specify a custom dispatch mode
								(This custom dispatch mode has to implement the
								<literal>org.objectweb.proactive.core.group.DispatchBehavior</literal>
								interface):
								<programlisting language="java">@DispatchMode(mode = DispatchMode.CUSTOM, customMode=CustomUnicastDispatch.class)</programlisting>
							</para>
						</listitem>
					</itemizedlist>

					<para>
						It is also possible to define a custom
						partition by specifying the partition
						algorithm in a class which implements the
						<literal>org.objectweb.proactive.core.component.type.annotations.multicast.ParamDispatch</literal>
						interface.
						<programlisting language="java">@ParamDispatchMetadata(mode=ParamDispatchMode.CUSTOM, customMode=CustomParametersDispatch.class))</programlisting>
					</para>

				</section>

				<section xml:id="Configurationthroughannotations_53"><info><title>Configuration through annotations</title></info>

					<note>
						<para>
							This implementation of collective
							interfaces extensively uses new features of the
							Java language introduced in Java 5, such as
							generics and annotations.
						</para>
					</note>

					<para>
						The distribution of parameters in this framework
						is specified in the definition of the multicast
						interface, using annotations.
					</para>

					<para>
						Elements of a multicast interface which can be
						annotated are: interface, methods and
						parameters. The different distribution modes are
						explained in the next section. The examples in
						this section all specify broadcast as the
						distribution mode.
					</para>

					<section xml:id="Interfaceannotations_53"><info><title>Interface annotations</title></info>

						<para>
							A distribution mode declared at the level of
							the interface defines the distribution mode
							for all parameters of all methods of this
							interface, but may be overridden by a
							distribution mode declared at the level of a
							method or of a parameter.
						</para>

						<para>
							The annotation for declaring distribution
							policies at level of an interface is
							<literal>@org.objectweb.proactive.core.component.type.annotations.multicast.ClassDispatchMetadata</literal>
						</para>

						<para>and is used as follows:</para>

						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_2.snip"/></textobject></programlisting>

					</section>

					<section xml:id="Methodannotations_53"><info><title>Method annotations</title></info>

						<para>
							A distribution mode declared at the level of
							a method defines the distribution mode for
							all parameters of this method, but may be
							overridden at the level of each individual
							parameter.
						</para>

						<para>
							The annotation for declaring distribution
							policies at level of a method is
							<literal>@org.objectweb.proactive.core.component.type.annotations.multicast.MethodDispatchMetadata</literal>
						</para>

						<para>and is used as follows:</para>

                  <programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_3.snip"/></textobject></programlisting>

						<para>
							Moreover, an another feature, inherited from
							the group framework of ProActive, is available:
							the dynamic dispatch.
						</para>

						<para>
							The
							<literal>org.objectweb.proactive.core.group.DispatchMode.DYNAMIC</literal>
							mode is applicable when there are more parameter
							partitions than bound server interfaces. A
							partitions is a set of arguments (list elements)
							that will be sent to server interfaces. For
							instance, instead of giving arguments one-by-one,
							you can use a 5-size partition which will send
							the first 5 arguments to the first server
							interface, the 5 next to the second interface and
							so on. Dynamic dispatch uses a knowledge-based
							policy, i.e. it collects information about request
							execution by server interfaces, and maintains a
							ranking among server interfaces	so that partitions
							are dispatched to the "best" server interface. A
							buffer can be configured, in which case buffered
							partitions are statically allocated to server
							interfaces, according to the static	dispatch policy.
						</para>

						<para>Dynamic dispatch must be used like this:</para>

						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_4.snip"/></textobject></programlisting>

					</section>

					<section xml:id="Parameterannotations_53"><info><title>Parameter annotations</title></info>

						<para>
							The annotation for declaring distribution
							policies at level of a parameter is
							<literal>@org.objectweb.proactive.core.component.type.annotations.multicast.ParamDispatchMetadata</literal>
						</para>

						<para>and is used as follows:</para>

						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_5.snip"/></textobject></programlisting>

					</section>

				</section>

				<section xml:id="Results_53"><info><title>Results</title></info>

					<para>
						The previous examples have been given with methods
						which do not return a result since we were focused on
						parameters. However, it is obviously possible to use
						multicast with server interfaces returning non-void
						results. This section aims at giving explanation on how
						to handle results.
					</para>

					<para>
						For each invoked method which returns a result
						of type
						<literal>T</literal>,
						a multicast invocation returns an aggregation
						of the results: a
						<literal>List&lt;T&gt;</literal>.
					</para>

					<para>
						There is a type conversion, from return type
						<literal>T</literal>
						in a method of the server interface, to return
						type
						<literal>List&lt;T&gt;</literal>
						in the corresponding method of the multicast
						interface. The framework transparently handles
						the type conversion between return types, which
						is just an aggregation of elements of type
						<literal>T</literal>
						into a structure of type
						<literal>list&lt;T&gt;</literal>.
					</para>

					<para>
						This implies that, for the multicast interface,
						the signature of the invoked method has to
						explicitly specify
						<literal>List&lt;T&gt;</literal>
						as a return type. This also implies that each
						method of the interface returns either nothing,
						or a list. Valid return types for methods of
						multicast interfaces are illustrated as follows:
					</para>

					<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_6.snip"/></textobject></programlisting>

					<para>
						Otherwise, there is also a possibility to
						customize the result values by processing a
						reduction on them. This mechanism allows to
						gather results and/or perform some operations on
						them.
					</para>

					<para>
						There is one reduction mechanism provided by
						default:
						<emphasis role="bold">SELECT_UNIQUE_VALUE</emphasis>.
						It allows to extract of the list of results the
						only one result that the list contains. For
						example, this is useful when your multicast mode
						is UNICAST, so you know that there will be only
						one element in your returned list.
					</para>

					<para>
						In order to use it, the multicast interface must
						use the
						<literal>@org.objectweb.proactive.core.component.type.annotations.multicast.Reduce</literal>
						annotation at the level of the methods which the
						results need to be reduced:
					</para>

					<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_7.snip"/></textobject></programlisting>

					<para>
						Or else, a custom reduce mode can also be used.
						For this case, the first step is to define the
						reduction algorithm into a class which
						implements the
						<literal>org.objectweb.proactive.core.component.type.annotations.multicast.ReduceBehavior</literal>
						interface. Then, the multicast interface can use
						the Reduce annotation, always at the level of
						the methods, by specifying the mode (CUSTOM) and
						the implementation class of the reduction to
						use:
					</para>

					<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_8.snip"/></textobject></programlisting>

					<para>
						This method will use the
						<literal>GetLastReduction</literal> algorithm which
						returns the last element of the list.
					</para>

					<para>
						Here is the the implementation of the
						<literal>GetLastReduction</literal> class:
					</para>

					<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_9.snip"/></textobject></programlisting>

				</section>

			</section>

			<section xml:id="Bindingcompatibility_3"><info><title>Binding compatibility</title></info>

				<para>
					Multicast interfaces manipulate lists of parameters
					(say<literal>List&lt;ParamType&gt;</literal>) and
					expect lists of results (say
					<literal>List&lt;ResultType&gt;</literal>).
					With respect to a multicast interface, connected
					server interfaces, on the contrary, may work with
					lists of parameters (
					<literal>List&lt;ParamType&gt;</literal>), but also
					with individual parameters (
					<literal>ParamType</literal>) and return individual
					results (<literal>ResultType</literal>).
				</para>

				<para>
					Therefore,
					<emphasis>
						the signatures of methods differ from a
						multicast client interface to its connected
						server interfaces
					</emphasis>. This is illustrated in the following
					figure: in picture
					<emphasis role="bold">a</emphasis>, the
					<literal>foo</literal> method of the multicast
					interface returns a list of elements of type
					<literal>T</literal> collected from the
					invocations to the server interfaces and in the
					picture <emphasis role="bold">b</emphasis>, the
					<literal>bar</literal> method distributes elements
					of type <literal>A</literal> to the connected
					server interfaces.
				</para>

				<para>
					<figure xml:id="comparison_of_signatures_between_client_multicast_and_server"><info><title>Comparison of signatures of methods between client multicast interfaces and server interfaces</title></info>
						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%" contentdepth="100%" align="center" fileref="images/png/multicast-signatures-lists.png" format="PNG"/>
							</imageobject>
						</mediaobject>
					</figure>
				</para>

				<para>
					For a given multicast interface, the type of server
					interfaces which may be connected to it can be
					inferred by applying the following rules:
				</para>

				<para>
					For a given multicast interface,
					<itemizedlist>
						<listitem>
							<para>
								the server interface must have the same
								number of methods
							</para>
						</listitem>
						<listitem>
							<para>
								for a given method method foo of the
								multicast interface, there must be a
								matching method in the server interface:
							</para>
							<itemizedlist>
								<listitem>
									<para>named foo</para>
								</listitem>
								<listitem>
									<para>
										which returns:
										<itemizedlist>
											<listitem>
												<para>
													void if the method
													in the multicast
													method returns void
												</para>
											</listitem>
											<listitem>
												<para>
													T if the multicast
													method returns
													list&lt;T&gt;
												</para>
											</listitem>
										</itemizedlist>
									</para>
								</listitem>
								<listitem>
									<para>
										for a given parameter
										List&lt;T&gt; in the multicast
										method, there must be a
										corresponding parameter, either
										List&lt;T&gt; or T, in the
										server interface, which matches
										the distribution mode for this
										parameter.
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
					</itemizedlist>
				</para>

				<para>
					The compatibility of interface signatures is
					verified automatically at binding time, resulting in
					a documented
					<literal>IllegalBindingException</literal> if
					signatures are incompatible.
				</para>

			</section>

	    </section>

		<section xml:id="Gathercastinterfaces_53"><info><title>Gathercast interfaces</title></info>

			<section xml:id="Definition_2"><info><title>Definition</title></info>

				<para>
					<emphasis role="bold">
						A gathercast interface transforms a list of
						invocations into a single invocation
					</emphasis>
				</para>

				<para>
					A gathercast interface is an abstraction for n-to-1
					communications. It handles data aggregation for
					invocation parameters, as well as process
					coordination. It gathers incoming data, and can also
					coordinate incoming invocations before continuing
					the invocation flow, by defining synchronization
					barriers.
				</para>

				<para>
					Gathering operations require knowledge of the
					participants on the collective communication (i.e.
					the clients of the gathercast interface). Therefore,
					the binding mechanism, when performing a binding to
					a gathercast interface, provides references on
					client interfaces bound to the gathercast interface.
					This is handled transparently by the framework. As a
					consequence, bindings to gathercast interfaces are
					bidirectional links.
				</para>

				<para>
					<figure xml:id="gathercast_for_primitive_and_composite_bleah"><info><title>Gathercast interfaces for primitive and composite components</title></info>
						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%" contentdepth="100%" align="center" fileref="images/png/gathercast-itfs.png" format="PNG"/>
							</imageobject>
						</mediaobject>
					</figure>
				</para>

			</section>

			<section xml:id="Datadistribution_101"><info><title>Data distribution</title></info>

				<para>
					Gathercast interfaces aggregate parameters from
					method invocations from client interfaces into lists
					of invocations parameters, and they redistribute
					results to each client interface.
				</para>

				<section xml:id="Gatheringofinvocationparameters"><info><title>Gathering of invocation parameters</title></info>

					<para>
						Invocation parameters are simply gathered into
						lists of parameters. The indexes of the
						parameters in the list correspond to the index of
						the parameters in the list of connected client
						interfaces, managed internally by the gathercast
						interface.
					</para>

					<para>
						<figure xml:id="aggregation_of_parameters_with_gathercast_interfaces_1"><info><title>Aggregation of parameters with a gathercast interface</title></info>
							<mediaobject>
								<imageobject>
									<imagedata scalefit="1" width="100%" contentdepth="100%" align="center" fileref="images/png/gathercast-aggregation.png" format="PNG"/>
								</imageobject>
							</mediaobject>
						</figure>
					</para>

				</section>

				<section xml:id="Redistributionofresults_53"><info><title>Redistribution of results</title></info>

					<para>
						The result of the invocation transformed by the
						gathercast interface is a list of values. Each
						result value is therefore indexed and
						redistributed to the client interface with the
						same index in the list of client interfaces
						managed internally by the gathercast interface.
					</para>

					<para>
						Similarly to the distribution of invocation
						parameters in multicast interfaces, a
						redistribution function could be applied to the
						results of a gathercast invocation, however this
						feature is not implemented yet.
					</para>

				</section>

			</section>

			<section xml:id="Bindingcompatibility_12"><info><title>Binding compatibility</title></info>

				<para>
					Gathercast interfaces manipulate lists of parameters
					(say <literal>List&lt;ParamType&gt;</literal>)
					and return lists of results (say
					<literal>List&lt;ResultType&gt;</literal>).
					With respect to a gathercast interface, connected
					client interfaces work with parameters which can be
					contained in the lists of parameters of the methods
					of the bound gathercast interface (ParamType), and
					they return results which can be contained in the
					lists of results of the methods of the bound
					gathercast interface (ResultType).
				</para>

				<para>
					Therefore, by analogy to the case of multicast
					interfaces,
					<emphasis>
						the signatures of methods differ from a
						gathercast server interface to its connected
						client interfaces
					</emphasis>.
					This is illustrated in the following figure: the
					foo methods of interfaces which are client of the
					gathercast interface exhibit a parameter of type
					<literal>V</literal>,
					the foo method of the gathercast interface
					exhibits a parameter of type
					<literal>List&lt;V&gt;</literal>.
					Similarly, the foo method of client interfaces
					return a parameter of type <literal>T</literal>
					whereas the foo method of the gathercast
					interface returns a parameter of type
					<literal>List&lt;T&gt;</literal>.
				</para>

				<para>
					The compatibility of interface signatures is
					verified automatically at binding time, resulting in
					a documented <literal>IllegalBindingException</literal>
					if signatures are incompatible.
				</para>

				<para>
					<figure xml:id="comparison_of_signature_methods_for_bindings_to_gathercast_interface"><info><title>Comparison of method signatures for bindings to a gathercast interface</title></info>
						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%" contentdepth="100%" align="center" fileref="images/png/gathercast-signatures.png" format="PNG"/>
							</imageobject>
						</mediaobject>
					</figure>
				</para>

			</section>

			<section xml:id="Processsynchronization_53"><info><title>Process synchronization</title></info>

				<para>
					An invocation from a client interface to a
					gathercast interface is asynchronous, which
					matches with the usual conditions for asynchronous
					invocations in ProActive. However the gathercast
					interface only creates and executes a new invocation
					with gathered parameters when all connected client
					interfaces have performed an invocation on it.
				</para>

				<para>
					It is possible to specify a timeout, which
					corresponds to the maximum amount of time between
					the moment when the first invocation of a client
					interface is processed by the gathercast interface,
					and those when the invocation of the last client
					interface is processed. Indeed, the gathercast
					interface will not forward a transformed invocation
					until all invocations of all client interfaces are
					processed by this gathercast interface.
				</para>

				<para>
					Timeouts for gathercast invocations are specified by
					an annotation on the method subject to the timeout,
					the value of the timeout is specified in
					milliseconds:
					<programlisting language="java">@org.objectweb.proactive.core.component.type.annotations.gathercast.MethodSynchro(timeout=20)</programlisting>
				</para>

				<para>
					If a timeout is reached before a gathercast
					interface could gather and process all incoming
					requests, a
					<literal>org.objectweb.proactive.core.component.exceptions.GathercastTimeoutException</literal>
					is returned to each client participating in the
					invocation. This exception is a
					<emphasis>runtime</emphasis> exception.
				</para>

				<para>
					It is also possible for gathercast interface not to
					wait for all invocations from connected client
					interfaces to perform an invocation by specifying
					the waitForAll attribute. Therefore, the gathercast
					interface will create and execute a new invocation
					on the first invocation received from any of the
					connected client interfaces.
				</para>

				<para>
					Thus, this specific feature can be used by the same
					annotation as for the timeout but with a different
					attribute:
					<programlisting language="java">@org.objectweb.proactive.core.component.type.annotations.gathercast.MethodSynchro(waitForAll=false)</programlisting>
					Therefore, the waitForAll attribute accepts boolean
					values and has for default value "true" (same
					behavior as if the annotation is not specified).
				</para>

				<para>
					Furthermore, it is forbidden to combine timeout and
					waitForAll set to false (an
					<literal>org.objectweb.fractal.api.factory.InstantiationException</literal>
					would be raised) because it would be incoherent.
				</para>

			</section>

		</section>

    </section>

	<section xml:id="component_deployment"><info><title>Deployment</title></info>

		<section xml:id="GCMDeployment_53"><info><title>Deploying components with the GCM Deployment</title></info>

			<section xml:id="Overview_1"><info><title>Overview</title></info>

				<para>
					To create a distributed component system, a deployment
					framework is available: the GCM Deployment.
				</para>

				<para>
					Distribution is achieved in a transparent manner over
					the Java RMI protocol thanks to the use of a stub/proxy
					pattern. Components are manipulated indifferently of
					their location (local or on a remote JVM). A complete
					description of the GCM Deployment can be found at
					<link xlink:href="../../ReferenceManual/multiple_html/GCMDeployment.html#GCMDeployment">Chapter 14. ProActive Grid Component Model Deployment</link>.
				</para>

				<para>
					In brief, this framework:
					<itemizedlist>
						<listitem>
							<para>
								connects to remote hosts using supported
								protocols, such as rsh, ssh, lsf, oar,
								etc...
							</para>
						</listitem>
						<listitem>
							<para>creates JVMs on these hosts</para>
						</listitem>
						<listitem>
							<para>
								instantiates components on these newly
								created JVMs
							</para>
						</listitem>
					</itemizedlist>
				</para>

			</section>

			<section xml:id="Initiatethedeployment_53"><info><title>Initiate the deployment</title></info>

				<para>
					The first step to distribute components is to initiate
					the deployment by loading the GCM Application
					Descriptor:
					<programlisting language="java">GCMApplication gcma = PAGCMDeployment.loadApplicationDescriptor(filePath);</programlisting>
					Then, the deployment must be started (i.e. creation of
					the remote JVMs):
					<programlisting language="java">gcma.startDeployment();</programlisting>
					The next step, distribute components, may be done
					through the ADL or the API.
				</para>

			</section>

			<section xml:id="DistributecomponentswithADL_53"><info><title>Distribute components with ADL</title></info>

				<para>
					Distribute components with ADL is quite simple:
					<itemizedlist>
						<listitem>
							<para>
								Put the GCMApplication into a
								<emphasis role="bold">java.util.Map</emphasis>
								with as key "deployment-descriptor":
							</para>
							<programlisting language="java">Map&lt;String, Object&gt; context = new HashMap&lt;String, Object&gt;();
context.put("deployment-descriptor", gcma);</programlisting>
						</listitem>
						<listitem>
							<para>
								Call the usual method to instantiate
								component through ADL (method
								<literal>org.objectweb.fractal.adl.Factory#newComponent()</literal>)
								with the Map containing the GCM Application
								as parameter:
							</para>
							<programlisting language="java">Component component = (Component) factory.newComponent("my.adl.folder.ComponentDefinition", context);</programlisting>
						</listitem>
					</itemizedlist>
					Thus, the component will be instantiated in a node
					of the virtual node specified in the ADL component
					definition (if a virtual node of the same name has
					also been defined in the GCM Application Descriptor).
				</para>

			</section>

			<section xml:id="DistributecomponentswithAPI_53"><info><title>Distribute components with API</title></info>

				<para>
					To distribute components with the API, the first
					thing to do is to get a node from a virtual node
					defined by the GCM Application Descriptor:
					<programlisting language="java">Map&lt;String, GCMVirtualNode&gt; vns = gcma.getVirtualNodes();
vns.get("VN1").waitReady();
Node node = vns.get("VN1").getANode();</programlisting>
					Then, the component must be instanced thanks to one
					of the methods provided by
					<literal>org.objectweb.proactive.core.component.factory.PAGenericFactory</literal>,
					taking as parameter the node obtained previously:
					<programlisting language="java">Component component = gf.newFcInstance(componentType, controllerDescription, contentDescription, node);</programlisting>
				</para>

			</section>

		</section>

		<section xml:id="ProActiveDeployment_53"><info><title>Deploying components with the ProActive Deployment</title></info>

			<para>
				The distribution of components may also be made by
				using the ProActive deployment framework. This
				deployment framework uses the concept of virtual
				nodes too but it just needs a single configuration file.
				Thus it may be used in a similar way. More information
				are available at
				<link xlink:href="../../ReferenceManual/multiple_html/XML_Descriptors.html">Chapter 15. XML Deployment Descriptors</link>.
			</para>

		</section>

		<section xml:id="VNDeployment_53"><info><title>Deploying components with ADL and Virtual Nodes</title></info>

			<para>
				It is also possible to deploy components with ADL without
				using a deployment (GCM or ProActive). To do this, the
				virtual node has to be directly set in the context using
				as key the virtual node name:
				<programlisting language="java">context.put(vn.getName(), vn);</programlisting>
				Of course, as many virtual
				nodes as needed can be set in the context. Then the component can be instantiated
				as usual:
				<programlisting language="java">Component component = (Component) factory.newComponent("my.adl.folder.ComponentDefinition", context);</programlisting>
				Thus, the component will be instantiated in a node
				of the virtual node specified in the ADL component
				definition (if a virtual node of the same name has
				also been set in the context).
			</para>

		</section>

		<section xml:id="NDeployment_53"><info><title>Deploying components with ADL and Nodes</title></info>

			<para>
				There is a last way to deploy components with ADL and
				without using deployment (GCM or ProActive) nor virtual
				node, using a list of nodes:
				<literal>java.util.List&lt;Node&gt;</literal>.
				This way is mostly useful for tests purpose
				since there is no control on which node each component
				will be instantiated.
			</para>

			<para>
				To deploy components using a list of nodes, the first
				step is to set this list in the context by setting the 
				"nodes" key (or by using the corresponding constant
				<literal>org.objectweb.proactive.core.component.adl.nodes.ADLNodeProvider.NODES_ID</literal>):
				<programlisting language="java">context.put("nodes", nodes);</programlisting>
				Then the component can be instantiated as usual:
				<programlisting language="java">Component component = (Component) factory.newComponent("my.adl.folder.ComponentDefinition", context);</programlisting>
				Therefore, the component will be instantiated on a node
				picked from the list. If the component is a composite
				component and has several subcomponents, each of them
				will be instantiated on different nodes. The node used
				is chosen randomly and there is no way to control which
				node is used to deploy a specific component. The only
				guarantee is that no node will be used twice until
				every node has been used at least once.
			</para>

		</section>

		<section xml:id="PrecisionsADL_53"><info><title>Precisions for component instantiation with ADL</title></info>

			<orderedlist>
				<listitem>
					<para>
						If no virtual node has been specified in the ADL
						component definition, the component is created in the
						local JVM.
					</para>
				</listitem>
				<listitem>
					<para>
						If a virtual node is defined in the ADL component
						definition and neither a deployment (GCM or ProActive)
						nor the virtual node has been set in the context (or
						there is no corresponding virtual node name),
						then the component is also created in the local
						JVM.
					</para>
				</listitem>
			</orderedlist>
			<note>
				<para>
					These two points do not apply if a list of
					nodes is set in the context.
				</para>
			</note>
		</section>

	</section>

	<section xml:id="Advanced_53"><info><title>Advanced</title></info>

		<section xml:id="configuration_html_controllers_n"><info><title>Controllers</title></info>

			<para>
				This section explains how to customize the component
				membranes through the configuration, composition and
				creation of controllers.
			</para>

			<section xml:id="Configurationofcontrollers_53"><info><title>Configuration of controllers</title></info>

				<para>
					It is possible to customize controllers, by
					specifying a control interface and an
					implementation.
				</para>

				<para>
					Controllers are configured in a simple XML
					configuration file, which has the following
					structure:
				</para>

				<programlisting language="xml"><textobject><textdata fileref="automatic_snippets/component_userguide_10.snip"/></textobject></programlisting>

				<para>The controllers do not have to be ordered.</para>

				<para>
					A default configuration file is provided, it
					defines the default controllers available for
					every ProActive component (super, binding, content,
					naming, lifecycle, multicast, gathercast, monitor
					and priority controllers, the interceptor controller
					is not available by default).
				</para>

				<para>
					A custom configuration file can be specified (in
					this example with "thePathToMyConfigFile") for any
					component in the controller tag of the ADL definition:
				</para>

				<programlisting language="java">&lt;definition name="name"&gt;
    ...
    &lt;controller desc="thePathToMyControllerConfigFile"/&gt;
    &lt;/definition&gt;
				</programlisting>

				<para>
					Or in the controller description parameter of the
					newFcInstance method from the Fractal/GCM API:
				</para>

				<programlisting language="java">componentInstance = componentFactory.newFcInstance(myComponentType,
   new ControllerDescription("name",myHierarchicalType,thePathToMyControllerConfigFile),
   myContentDescription);
				</programlisting>

			</section>

			<section xml:id="Writingacustomcontroller_53"><info><title>Writing a custom controller</title></info>

				<para>
					The controller interface is a standard interface
					which defines which methods are available.
				</para>

				<para>
					When a new implementation is defined for a given
					controller interface, it has to conform to the
					following rules:
				</para>

				<orderedlist>
					<listitem>
						<para>
							The controller implementation has to extend
							the <literal>AbstractPAController</literal>
							class, which is the base class for component
							controllers in ProActive, and which defines the
							constructor
							<literal>AbstractPAController(Component owner)</literal>.
						</para>
					</listitem>
					<listitem>
						<para>
							The controller implementation must override
							this constructor:
						</para>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_11.snip"/></textobject></programlisting>
					</listitem>
					<listitem>
						<para>
							The controller implementation must also
							override the abstract method
							<literal>setControllerItfType()</literal>,
							which sets the type of the controller
							interface:
						</para>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_12.snip"/></textobject></programlisting>
					</listitem>
					<listitem>
						<para>
							The controller interface and its
							implementation have to be declared in the
							component configuration file.
						</para>
					</listitem>
					<listitem>
						<para>
							The controller interface name must end by
							"-controller".
						</para>
					</listitem>
				</orderedlist>

			</section>

		</section>

		<section xml:id="Exporting_components_as_Web_Services"><info><title>Exporting components as Web Services</title></info>

			<section xml:id="WS_Overwiew"><info><title xml:id="Overview_290">Overview</title></info>

				<para>
					This feature allows to expose interfaces of a component
					as a web service and thus, to call them from any client
					written in any foreign language.
				</para>

				<para>
					Indeed, applications written in C#, for instance, cannot
					communicate with ProActive applications. We have chosen
					web services technology to enable interoperability because
					they are based on XML and HTTP. Thus, any component
					interface can be accessible from any enabled web services
					language.
				</para>

			</section>

			<section xml:id="Principles_29"><info><title>Principles</title></info>

				<para>
					A <emphasis role="bold">web service</emphasis> is a
					software entity, providing one or several functionalities,
					that can be exposed, discovered and accessed over the
					network. Moreover, web services technology allows
					heterogeneous applications to communicate and exchange
					data in a remotely way. In our case, the useful elements,
					of web services are:
				</para>

				<itemizedlist>
					<listitem>
						<para><emphasis role="bold">The SOAP Message</emphasis></para>
						<indexterm>
							<primary>SOAP</primary>
						</indexterm>
						<para>
							The SOAP message is used to exchange XML based
							data over the internet. It can be sent via HTTP
							and provides a serialization format for
							communicating over a network.
						</para>
					</listitem>
					<listitem>
						<para><emphasis role="bold">The HTTP Server</emphasis></para>
						<para>
							HTTP is the standard web protocol generally used
							over the 80 port. In order to receive SOAP
							messages, you can either install an HTTP server
							that will be responsible of the data transfer or
							use the default HTTP server which is a Jetty
							server. However, This server is not sufficient to
							treat a SOAP request. For this, you also need a
							SOAP engine.
						</para>
					</listitem>
					<listitem>
						<para><emphasis role="bold">The SOAP Engine</emphasis></para>
						<para>
							A SOAP Engine is the mechanism responsible of
							making transparent the unmarshalling of the
							request and the marshalling of the response. Thus,
							the service developer doesn't have to worry with
							SOAP. In our case, we use Apache CXF which can be
							installed into any HTTP server.
						</para>
					</listitem>
					<listitem>
						<para><emphasis role="bold">The client</emphasis></para>
						<para>
							Client's role is to consume a web service. It is
							the producer of the SOAP message. The client
							developer doesn't have to worry about how the
							service is implemented. The CXF java libraries
							provide classes to easily invoke a service
							(see examples).
						</para>
					</listitem>
				</itemizedlist>

				<figure xml:id="SOAP_call_steps"><info><title>Steps taken when an active object is called via SOAP</title></info>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/provider_en.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>

			</section>

			<section xml:id="PrerequisiteInstallingtheWebServerandtheSOAP"><info><title>Pre-requisite: Installing the Web Server and the SOAP engine</title></info>

				<para>
					If you want to expose your components on the local
					embedded Jetty server or on Jetty servers deployed
					during your deployment, you just have to deploy
					ProActive using the <literal>build deploy</literal>
					command into the <literal>compile</literal> directory.
					If you want to expose them on an other http server, you
					have to build the <literal>proactive.war</literal>
					archive. For this, you have to go into your
					<literal>compile</literal> directory of your ProActive
					home and type
					<literal>build proActiveWar</literal>. The
					<literal>proactive.war</literal> file will be built into
					the <literal>dist</literal> directory.
				</para>

				<para>
					If you have chosen to use the default Jetty server, then
					you have nothing else to do. Jetty server will
					automatically take files it needs.
				</para>

				<para>
					If you have chosen to use your own HTTP server, then you
					just have to copy the proactive.war file into the
					<literal>webapp</literal> directory of your HTTP server.
					Some HTTP servers need to be restarted to take into account
					this new web application but some others like Tomcat can
					handle hot deployment and, thus, do not need to be restarted.
				</para>

				<warning>
					<para>
						If you use your own HTTP server, you have to be aware that
						the Jetty server will be launched. Most of ProActive
						examples are launched with the option
						'-Dproactive.http.port=8080' which specifies Jetty port.
						So, if you want to use your own server on port 8080, you
						have to modify the jetty port in launching scripts or to
						change the port of your own server.
					</para>
				</warning>

			</section>

			<section xml:id="Stepstoexposeanactiveobjectasa_29"><info><title>Steps to expose/unexpose a component as a web services using the <literal>WebServices</literal> interface</title></info>

				<para>
					There are two ways of exposing and unexposing a component as a
					web service: the first one is the same as we can do with
					active objects and the second one uses the
					<literal>PAWebServicesController</literal>, which is a
					component controller dedicated to the web services exposition.
					This section deals with the first method.
				</para>

				<para>
					The steps for exporting and using a component as a web service
					are the following:
				</para>

				<itemizedlist>
					<listitem>
						<para>
							Create, instantiate and start your component in a
							classic way as below:
						</para>

						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_1.snip" /></textobject></programlisting>
					</listitem>
					<listitem>
						<para>
							Once the element created and activated, a
							<emphasis role="bold">WebServicesFactory</emphasis>
							object has to be instantiated:
						</para>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_6.snip" /></textobject></programlisting>
						<para>or</para>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_7.snip" /></textobject></programlisting>
					</listitem>
					<listitem>
						<para>
							Then, you have to instantiate a
							<emphasis role="bold">WebServices</emphasis> object
							as follows:
						</para>
						<programlisting language="java">WebServices ws = wsf.getWebServices(myUrl);</programlisting>
						<para>
							If you want to use the local Jetty server to expose
							your component, you can use the following line to
							retrieve the good URL:
						</para>
						<programlisting language="java">String myUrl = AbstractWebServicesFactory.getLocalUrl();</programlisting>
						<para>
							This will get the Jetty port which is a random
							port and build the url.
						</para>
					</listitem>
					<listitem>
						<para>
							And finally, you can use one of the
							<literal>WebServices</literal> methods:
						</para>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/WebServices_Methods_Components.snip" /></textobject></programlisting>
						<para>where:</para>
						<itemizedlist>
							<listitem>
								<para><emphasis role="bold">component</emphasis> is the component</para>
							</listitem>
							<listitem>
								<para>
									<emphasis role="bold">componentName</emphasis>
									the first part of the service name which will
									identify the component on the server. The service
									will be exposed at the address
									http://[host]:[port]/proactive/services/componentName_interfaceName
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis role="bold">interfaceNames</emphasis>
									is a String array containing the interface names
									of the component you want to make accessible. If
									this parameters is null (or is absent), all the
									functional server interfaces of the component
									will be exposed.
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</itemizedlist>

			</section>

			<section xml:id="Stepstoexposeanactiveobjectasa_30"><info><title>Steps to expose/unexpose a component as a web services using <literal>PAWebServicesController</literal></title></info>

				<para>
					As said in the previous section, it is possible to expose web
					services in two different manners. This section explains how
					to proceed with the dedicated web services controller.
				</para>

				<itemizedlist>
					<listitem>
						<para>
							First, instantiate your component with the web service
							controller:
						</para>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_11.snip" /></textobject></programlisting>
						<para>
							The first line is meant to retrieve the path of the
							controller file. This file is located at
							<literal>"&lt;your ProActive Home&gt;/src/Extensions/org/objectweb/proactive/extensions/webservices/cxf/initialization/cxf-component-config.xml"</literal>.
						</para>
					</listitem>
					<listitem>
						<para>Then, get the controller to be able to use it:</para>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_12.snip" /></textobject></programlisting>
					</listitem>
					<listitem>
						<para>
							Then, you have to set the url where you want the
							controller exposes the service:
						</para>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_13.snip" /></textobject></programlisting>
						<para>
							If you want to use the local Jetty server to expose
							your component, you can use the following line to
							retrieve the good URL:
						</para>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_14.snip" /></textobject></programlisting>
						<para>
							This will get the Jetty port which is a random port
							and build the url.
						</para>
					</listitem>
					<listitem>
						<para>
							And finally, you can use one of the
							<literal>PAWebServicesController</literal> methods:
						</para>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/PAWebServicesController_expose_methods.snip" /></textobject></programlisting>
						<para>where:</para>
						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">componentName</emphasis>
									the first part of the service name which
									will identify the component on the server.
									The service will be exposed at the address
									http://[host]:[port]/proactive/services/componentName_interfaceName
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis role="bold">interfaceNames</emphasis>
									is a String array containing the interface
									names of the component you want to make
									accessible. If this parameters is null (or
									is absent), all the functional server
									interfaces of the component will be exposed.
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</itemizedlist>

			</section>

			<section xml:id="exposeonremotejettyservers_29"><info><title>Exposing as a web service on remote Jetty servers launched during the deployment</title></info>
				<para>
					When you call the exposition of your component, the CXF
					servlet is deployed on the local Jetty server. It is
					therefore possible to expose your object locally without
					doing anything else.
				</para>

				<para>
					Now, let us assume that your component is deployed on a remote
					node. In that case, you have a running jetty server on the
					remote host containing this node but no servlet has been
					deployed on it. So, if you want to expose your component on
					the remote host, you will have to make a small modification of
					the previous piece of code.
				</para>

				<para>
					The web service extension provides classes that implements the
					<literal>InitActive</literal> interface which are in charge of
					deploying the CXF servlet on the host where your object has
					been initialized. Thus, you just have to instantiate your
					component using this implementation of
					<literal>InitActive</literal>.
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_9.snip" /></textobject></programlisting>

				<para>
					If you have chosen to use the
					<literal>PAWebServicesController</literal> controller, you do
					not need to modified your component instantiation but instead,
					before the first exposition, you just have to call the
					following method on the controller:
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_16.snip" /></textobject></programlisting>

				<para>
					Now, let us assume that your component is deployed on a node
					or locally and that you want to expose it on a host where
					another node is deployed. On this host, there is only a
					running Jetty server without any web services servlet. If
					you are using the web services controller, it is really
					straight forward. You just have to put a node as an argument of
					the previous method:
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_17.snip" /></textobject></programlisting>

				<para>
					If you are not using the controller, you can use the following
					line:
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_AO_8.snip" /></textobject></programlisting>

				<para>
					Then, you can expose your component as a web service as in
					<xref linkend="Stepstoexposeanactiveobjectasa_29"/>.
				</para>

			</section>

			<section xml:id="Accessingtheservices_29"><info><title>Accessing the services</title></info>

				<para>
					Once the component interface exposed, you can access it via
					any web service client (such as C#, SoapUI, Apache CXF API,
					Apache Axis2 API, ...) or with your favorite browser (only if
					the returned type of your service methods are primitive
					types).
				</para>

				<para>
					First of all, the client will get the WSDL file matching this
					component interface. This WSDL file is the 'identity card' of
					the service. It contains the web service public interfaces and
					its location. Generally, WSDL files are used to generate a proxy
					to the service. For example, for a given service, say
					'componentTest_computeItf', you can get the WSDL document at
					<code>http://[host]:[port]/proactive/services/componentTest_computeItf?wsdl</code>.
				</para>

				<para>
					Now that this client knows what and where to call the service,
					it will send a SOAP message to the web server. The web server
					looks into the message and performs the right call. Then, it
					returns the response into another SOAP message to the client.
				</para>

			</section>

			<section xml:id="Limitations_29"><info><title>Limitations</title></info>

				<para>
					Contrary to the previous version of the component exposition
					using Apache SOAP, this new version which uses Axis2 or CXF
					can handle complex types. That is, with this version, you can
					implement a service which exposes a method returning or taking
					in argument an instance of any class. By using CXF and JAX-WS
					annotations, there is no limitation on the type of this class.
					It only implies to use the appropriate adapters (see the
					<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://cxf.apache.org/docs/index.html">
						CXF documentation
					</link> for more details). However, if you do not want to use
					JAX-WS annotations or CXF, the class of this instance has to
					respect some criterion due to the serialization and Axis2/CXF
					restrictions:
				</para>

				<itemizedlist>
					<listitem>
						<para>This class has to be serializable</para>
					</listitem>
					<listitem>
						<para>
							This class has to supply a no-args constructor and
							preferably empty
						</para>
					</listitem>
					<listitem>
						<para>
							All the fields of this class has to be private or
							protected
						</para>
					</listitem>
					<listitem>
						<para>
							This class has to supply public getters and setters
							for each field. These getter and setter methods have
							to be in this class and not in one of its super
							classes.
						</para>
					</listitem>
				</itemizedlist>

			</section>

			<section xml:id="AsimpleexampleHelloWorld_29"><info><title>A simple example: Hello World</title></info>

				<para>
					Let's start with a simple example, an Helloworld component with
					two interfaces exposed as a web service:
				</para>

				<para>
					First, below are the two server interfaces of the component:
					<programlisting language="java"><textobject><textdata fileref="automatic_snippets/helloworlditfcomponent.snip"/></textobject></programlisting>
					<programlisting language="java"><textobject><textdata fileref="automatic_snippets/goodbyeworlditfcomponent.snip"/></textobject></programlisting>
				</para>

				<para>
					The implementation class of the component is the following one:
					<programlisting language="java"><textobject><textdata fileref="automatic_snippets/helloworldcomponent.snip"/></textobject></programlisting>
				</para>

				<para>
					The following piece of code creates the component and exposes
					its interfaces as a web services.
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_4.snip" /></textobject></programlisting>

				<para>
					If you want to use the web service controller, you should write
					the following line:
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_18.snip" /></textobject></programlisting>

				<para>
					All the interfaces (<literal>hello-world</literal> and
					<literal>goodbye-world</literal>) of the component
					<literal>helloWorld</literal> have been deployed as web services
					on the web server located at
					<literal>http://localhost:8080/proactive/services/</literal> and
					its service names are
					<literal>"MyHelloWorldComponentService_hello-world"</literal> and
					<literal>"MyHelloWorldComponentService_goodbye-world"</literal>.
					You can see the wsdl files through
					<literal>http://localhost:8080/proactive/services/MyHelloWorldComponentService_hello-world?wsdl</literal>
					and
					<literal>http://localhost:8080/proactive/services/MyHelloWorldComponentService_goddbye-world?wsdl</literal>
					and you can call the <literal>sayHello</literal> method of the
					<literal>hello-world</literal> interface with your browser
					through
					<literal>http://localhost:8080/proactive/services/MyHelloWorldComponentService_hello-world/sayHello</literal>.
				</para>

				<para>
					If you have exposed a method which requires arguments, you can
					call it using the same link as previously but adding
					<literal>?[arg0]=[value]&amp;[arg1]=[value]...</literal> where
					[argn] is the name of the n-th argument as written in the WSDL
					file.
				</para>

				<para>
					You can also call a webservice using the ProActive client which
					uses a CXF client. Here is an example:
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservices_Component_5.snip" /></textobject></programlisting>

			</section>

		</section>

		<section xml:id="Webservicebindings_53"><info><title>Web service bindings</title></info>

			<para>
				ProActive also gives the possibility to bind a functional
				client interface of a component to a web service.
			</para>

			<para>
				For	instance, this feature is useful to enable
				communication between SCA (Service Component Architecture)
				components and GCM/ProActive components by using the web
				service communication protocol. Effectively, communication
				from SCA component to GCM/ProActive component can be done
				thanks to the ability of exposing GCM server interface as
				web service (See
				<xref linkend="Exporting_components_as_Web_Services"/>)
				and communication from GCM/ProActive component to SCA
				component can be done by using this feature. This has
				already been successfully tested with two SCA
				implementations:
				<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://tuscany.apache.org/">
					Apache Tuscany
				</link>
				and
				<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://wiki.ow2.org/frascati/">
					FraSCAti
				</link>.
			</para>

			<para>
				The only requirement for binding a client interface to a
				web service is that the web service must be known in
				advance in order to ensure the compatibility between
				the client interface and the web service to bind to.
				In other words, the Java interface representing the
				client interface must have the same method signatures
				than those exposed by the web service.
			</para>

			<para>
				It is the same principle to bind a client interface to a
				web service with both the ADL and the API: the web
				service binding can be done just by replacing the server
				interface name by the URL of the web service (not the WSDL
				address) in the call to the method <literal>bindFc</literal>
				with the API or in the tag <literal>binding</literal> with
				the ADL.
			</para>

			<para>
				By default, the CXF API is used to call the web service, but
				it is also possible to specify another library. If so, the URL
				has to be followed, in parenthesis, by the ID or the full name
				of the class to use to call the web service. Thus, ProActive
				offers several ways to call web services by using various
				configurations of CXF API. IDs are defined in the class
				<literal>org.objectweb.proactive.core.component.webservices.WSInfo</literal>.
				Otherwise, the full	class name has to be the one of a class
				implementing the
				<literal>org.objectweb.proactive.core.component.webservices.PAWSCaller</literal>
				interface:
				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/proactivewscaller.snip"/></textobject></programlisting>
			</para>

			<para>
				For instance, the replacing string of the server interface
				name may be:
				<itemizedlist>
					<listitem>
						<para>
							"http://localhost:8080/proactive/services/Server_HelloWorld(org.objectweb.proactive.core.component.webservices.CXFWSCaller)"
						</para>
					</listitem>
					<listitem>
						<para>
							which is equivalent to: "http://localhost:8080/proactive/services/Server_HelloWorld(" + org.objectweb.proactive.core.component.webservices.WSInfo.CXFWSCALLER_ID + ")"
						</para>
					</listitem>
					<listitem>
						<para>
							which is also equivalent to: "http://localhost:8080/proactive/services/Server_HelloWorld"
							since CXF is used by default.
						</para>
					</listitem>
				</itemizedlist>
			</para>

		</section>

		<section xml:id="Lifecycle_encapsulation_of_functional_activity_in_component_lifecycle"><info><title>Lifecycle: encapsulation of functional activity in component lifecycle</title></info>

			<indexterm>
				<primary>Lifecycle</primary>
				<secondary>Components</secondary>
			</indexterm>

			<para>
				In this implementation of the Fractal/GCM component model,
				Fractal/GCM components are active objects. Therefore, it is
				possible to redefine their activity. In this context of
				component based programming, we call an activity
				redefined by a user a
				<emphasis role="bold">functional activity</emphasis>.
			</para>

			<para>
				When a component is instantiated, its lifecycle is in
				the STOPPED state, and the functional activity that a
				user may have redefined is not started yet. Internally,
				there is a default activity which handles controller
				requests in a FIFO order.
			</para>

			<para>
				When the component is started, its lifecycle goes to the
				STARTED state, and then the functional activity is
				started: this activity is initialized (as defined in
				InitActive), and run (as defined in RunActive).
			</para>

			<para>
				2 conditions are required for a smooth integration
				between custom management of functional activities and
				lifecycle of the component:
			</para>

			<indexterm>
				<primary>Request Queue</primary>
			</indexterm>

			<orderedlist>
				<listitem>
					<para>
						the control of the request queue has to use the
						<literal>org.objectweb.proactive.Service</literal>
						class
					</para>
				</listitem>
				<listitem>
					<para>
						the functional activity has to loop on the
						<literal>body.isActive()</literal> condition.
						This is not compulsory but it allows to
						automatically end the functional activity when the
						lifecycle of the component is stopped. It may also
						be managed with a custom filter.
					</para>
				</listitem>
			</orderedlist>

			<para>
				Control invocations to stop the component will
				automatically set the <literal>isActive()</literal> return
				value to false, which implies that when the functional
				activity loops on the <literal>body.isActive()</literal>
				condition, it will end when the lifecycle of the component
				is set to STOPPED.
			</para>

			<note>
				<para>
					By the way, it should be specified that in this
					implementation of the
					<literal>org.etsi.uri.gcm.api.control.GCMLifeCycleController</literal>,
					the <literal>startFc</literal> and
					<literal>stopFc</literal> methods are recursive (ie.
					starting or stopping a component, starts or stops
					all its subcomponents) whereas the
					<literal>terminateGCMComponent</literal> method is not
					recursive (ie. only terminates the current component).
				</para>
			</note>

		</section>

		<section xml:id="Structuringthemembranewithnonfunctionalcomponents_53"><info><title>Structuring the membrane with non-functional components</title></info>

			<para>
				Components running in dynamically changing execution
				environments need to adapt to these environments. In
				Fractal/GCM component model, adaptation mechanisms are
				triggered by the non-functional (NF) part of the
				components. Interactions with execution environments may
				require complex relationships between controllers. In
				this section, we focus on the adaptability of the
				membrane. Examples include changing communication
				protocols, updating security policies, or taking into
				account new runtime environments in case of mobile
				components. Adaptability implies that evolutions of the
				execution environments have to be detected and acted
				upon. It may also imply interactions with the
				environment and with other components for realizing the
				adaptation.
			</para>

			<para>
				We provide tools for adapting controllers. These
				tools manage (re)configuration of controllers inside
				the membrane. For this, we provide a model and an
				implementation, using a standard component-oriented
				approach for both the application (functional) level
				and the control (NF) level. Having a component-oriented
				approach for the non-functional aspects also allows
				them to benefit from the structure, hierarchy and
				encapsulation provided by a component-oriented approach.
			</para>

			<para>
				In this section, we propose to design NF concerns as
				compositions of components as suggested in the GCM
				proposal. Our general objective is to allow controllers
				implemented as components to be directly plugged in a
				component membrane. These controllers take advantage of
				the properties of component systems like
				<emphasis>reconfigurability</emphasis>, i.e. changing of
				the contained components and their bindings. This allows
				components to be dynamically adapted in order to suit
				changing environmental conditions. Indeed, we aim at a
				component platform appropriate for
				<emphasis>autonomic Grid applications</emphasis>; those
				applications aim at ensuring some quality of services
				and other NF features without being geared by an
				external entity.
			</para>

			<para>
				Components in the membrane introduce two major changes:
				first, refinements of the Fractal/GCM model concerning
				the structure of a membrane; secondly, a definition and
				an implementation of an API that allows membranes to be
				themselves composed of components, possibly distributed.
				Both for efficiency and for flexibility reasons, we
				provide an implementation where controllers can either
				be classical objects or full components that could even
				be distributed. We believe that this high level of
				flexibility is a great advantage of this approach over
				the existing ones
				<citation><xref linkend="MB01" endterm="mb01.abbrev"/>, <xref linkend="SPC01" endterm="spc01.abbrev"/></citation>.
				Our model refinements also provide a better structure for
				the membrane and a better decoupling between the membrane
				and its externals. Finally, our approach gives the
				necessary tools for membrane reconfiguration, providing
				flexibility and evolution abilities. The API we present
				can be split in two parts:
				<itemizedlist mark="opencircle">
					<listitem>
						<para>
							Methods dedicated to component instantiation:
							they allow the specification of the NF part of
							the type of a component and the instantiation
							of NF components.
						</para>
					</listitem>
					<listitem>
						<para>
							Methods for the management of the membrane: they
							consist in managing the content, introspecting,
							and managing the life-cycle of the membrane.
							Those methods are proposed as an extension of the
							Fractal component model and consequently of the
							GCM model.
						</para>
					</listitem>
				</itemizedlist>
			</para>

			<section xml:id="Motivatingexample_53"><info><title>Motivating example</title></info>

				<para>
					Here we present a simple example that shows the advantages
					of componentizing controllers of components. In our
					example, we are considering a naive solution for securing
					communications of a composite component. As described in
					<xref linkend="figNaiveSolution"/>, secure communications
					are implemented by three components inside the membrane:
					Interceptor, Decrypt, and Alert. The scenario of the
					example is the following: the composite component receives
					encrypted messages on its server functional interface. The
					goal is to decrypt those messages. First, the incoming
					messages are intercepted by the Interceptor component. It
					forwards all the intercepted communications to Decrypt,
					which can be an off-the-shelf component (written by
					cryptography specialists) implementing a specific
					decryption algorithm. The Decrypt component receives a key
					for decryption through the non-functional server interface
					of the composite (interface number 1 on the figure). If it
					successfully decrypts the message, the Decrypt component
					sends it to the internal functional components, using the
					functional internal client interface (2). If a problem
					during decryption occurs, the Decrypt component sends a
					message to the Alert component. The Alert component is in
					charge of deciding on how to react when a decryption
					fails. For example, it can contact the sender (using the
					non-functional client interface – 3) and ask it to send
					the message again. Another security policy would be to
					contact a “trust and reputation” authority to signal a
					suspicious behaviour of the sender. The Alert component is
					implemented by a developer who knows the security policy of
					the system. In this example, we have three well-identified
					components, with clear functionalities and connected through
					well-defined interfaces. Thus, we can dynamically replace
					the Decrypt component by another one, implementing a
					different decryption algorithm. Also, for changing the
					security policy of the system, we can dynamically replace
					the Alert component and change its connexions. Compared to a
					classical implementation of secure communications (for
					example with objects), using components brings to the
					membrane a better structure and reconfiguration
					possibilities. To summarize, componentizing the membrane in
					this example provides dynamic adaptability and
					reconfiguration; but also re-usability and composition from
					off-the-shelf components.
				</para>

				<figure xml:id="figNaiveSolution"><info><title>Example: architecture of a naive solution for secure communications</title></info>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/Significant_example.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>

			</section>

			<section xml:id="AstructureforComponentizedMembranes_53"><info><title>A structure for Componentized Membranes</title></info>

				<para>
					<figure xml:id="figStructure"><info><title>Structure for the membrane of Fractal/GCM components</title></info>
						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/Overall_picture.png" format="PNG"/>
							</imageobject>
						</mediaobject>
					</figure>
					<xref linkend="figStructure"/> shows the structure we suggest for
					the component membrane. The membrane (in gray) consists of one
					object controller and two component controllers, the component
					controllers are connected together and with the outside of the
					membrane by different bindings. For the moment, we do not specify
					whether components are localized with the membrane or distributed.
				</para>

				<para>
					Before defining an API for managing components inside the membrane,
					the definition of the membrane given by the GCM specification needs
					some refinements. Those refinements, discussed in this section,
					provide more details about the structure a membrane can adopt.
					<xref linkend="figStructure"/> represents the structure of a
					membrane and gives a summary of the different kinds of interface
					roles and bindings that a component can provide. As stated in the
					GCM specification, NF interfaces are not only those specified in
					the Fractal specification, which are only external server ones.
					Indeed, in order to be able to compose NF aspects, the GCM requires
					the NF interfaces to share the same specification as the functional
					ones: role, cardinality, and contingency. For example, in GCM,
					client NF interfaces allow the composition of NF aspects and
					reconfigurations at the NF level. Our model is also flexible, as
					all server NF interfaces can be implemented by both objects or
					components controllers.
				</para>

				<para>
					All the interfaces showed in <xref linkend="figStructure"/> give
					the membrane a better structure and enforce decoupling between the
					membrane and its externals. For example, to connect
					<emphasis>nfc</emphasis> with <emphasis>fns</emphasis>, our model
					adds an additional stage: we have first to perform binding
					<emphasis>b3</emphasis>, and then binding <emphasis>b9</emphasis>.
					This avoids <emphasis>nfc</emphasis> to be strongly coupled with
					<emphasis>fns</emphasis>: to connect <emphasis>nfc</emphasis> to
					another <emphasis>fns</emphasis>, only binding
					<emphasis>b9</emphasis> has to be changed. In
					<xref linkend="figStructure"/>, some of the links are represented
					with dashed arrows. Those links are not real bindings but “alias”
					bindings (e.g. b3); the source interface is the alias and it is
					“merged” with the destination interface. These bindings are similar
					to the export/import bindings existing in Fractal (b6, b10) except
					that no interception of the communications on these bindings is
					allowed.
				</para>

				<section xml:id="Performanceissues_53"><info><title>Performance issues</title></info>

					<para>
						While componentizing the membrane clearly improves its
						programmability and its capacity to evolve, one can wonder what
						happens to performance. First, as our design choice allows
						object controllers, one can always keep the efficiency of
						crucial controllers by keeping them as objects. Second, the
						overhead for using components instead of objects is very low if
						the controllers components are local, and are negligible compared
						to the communication time, for example. Finally, if controllers
						components are distributed, then there can be a significant
						overhead induced by the remote communications, but if
						communications are asynchronous, and the component can run in
						parallel with the membrane, this method can also induce a
						significant speedup, and a better availability of the membrane.
						To summarize, controllers invoked frequently and performing very
						short treatments would be more efficiently implemented by local
						objects or local components. For controllers called less frequently
						or which involve long computations, making them distributed would
						improve performances and availability of the membrane.
					</para>

				</section>

			</section>

			<section xml:id="AnAPIforReconfiguringNonfunctionalAspects_53"><info><title>An API for (Re)configuring Non-Functional Aspects</title></info>

				<section xml:id="NonfunctionalTypeandNonfunctionalComponents_53"><info><title>Non-functional Type and Non-functional Components</title></info>

					<para>
						To type check bindings between membranes, we have to extend the GCM
						model: the type of a component must includes a non-functional part.
						This part is defined as the union of the types of NF interfaces the
						membrane exposes. To specify the NF part in the type of a component,
						we defined the classes:
						<itemizedlist>
							<listitem>
								<para>
									<literal>PAComponentType</literal> which is an extension
									of the <literal>ComponentType</literal> class and adds
									methods to access to the non functional interface types
									of a component type. 
								</para>
							</listitem>
							<listitem>
								<para>
									<literal>PAGCMTypeFactory</literal> which is an extension
									of the <literal>GCMTypeFactory</literal> class and adds a
									method to create a <literal>PAComponentType</literal>.
								</para>
							</listitem>
						</itemizedlist>
						Then the component can be instantiated as usually by using the
						<literal>newFcInstance</literal> method where the type given as
						parameter is an instance of <literal>PAComponentType</literal>.
					</para>

					<para>
						Components inside the membrane are
						<emphasis>non-functional components</emphasis>. They are similar to
						functional ones. However, their purpose is different because they deal
						with NF aspects of the <emphasis>host component</emphasis>. Thus, in
						order to enforce separation of concerns, we restrict the interactions
						between functional and NF components. For example, a NF component
						cannot be included inside the functional content of a composite.
						Inversely, a functional component cannot be added inside a membrane.
						As a consequence, direct bindings between functional interfaces of NF
						and functional components are forbidden. In the generic factory, a
						method named newNfFcInstance that creates this new kind of components
						has been added:
						<programlisting language="java">public Component newNfFcInstance(Type fType, any contentDesc, any controllerDesc);</programlisting>
						Parameters of this method are identical to its functional equivalent and
						NF components are created in the same way as functional ones.
					</para>

				</section>

				<section xml:id="APIforthemanagementofthemembrane_53"><info><title>API for the membrane management</title></info>

					<para>
						<figure xml:id="codeAPI1"><info><title>The primitives for managing the membrane.</title></info>
							<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_16.snip"/></textobject></programlisting>
						</figure>
						To manipulate components inside membranes, we introduce primitives to
						perform basic operations like adding, removing or getting a reference
						on a NF component. We also need to perform calls on well-known
						Fractal/GCM controllers (life-cycle controller, binding controller...)
						of these components. So, we extend Fractal/GCM specification by adding
						a new controller called membrane controller. As we want it to manage
						all the controllers, it is the only mandatory controller that has to
						belong to any membrane. It allows the manual composition of membranes
						by adding the desired controllers. The methods presented in
						<xref linkend="codeAPI1"/> are included in the MembraneController
						interface; they are the core of the API and are sufficient to perform
						all the basic manipulations inside the membrane. They add, remove, or
						get a reference on a NF component. They also allow the management of
						object controllers and membrane’s life-cycle. Referring to Fractal,
						this core API implements a subset of the behavior of the life-cycle
						and content controllers specific to the membrane. This core API can
						be included in any Fractal/GCM implementation. Reconfigurations of
						NF components inside the membrane are performed by calling standard
						Fractal controllers. The general purpose API defines the following
						methods:
						<itemizedlist mark="opencircle">
							<listitem>
								<para>
									<literal>nfAddFcSubComponent(Component component)</literal>:
									adds the NF component given as argument to the membrane;
								</para>
							</listitem>
							<listitem>
								<para>
									<literal>nfRemoveFcSubComponent(Component component)</literal>:
									removes the specified NF component from the membrane;
								</para>
							</listitem>
							<listitem>
								<para>
									<literal>nfGetFcSubComponents()</literal>: returns an array
									containing all the NF components;
								</para>
							</listitem>
							<listitem>
								<para>
									<literal>nfGetFcSubComponent(string name)</literal>: returns
									the specified NF component, the string argument is the name
									of the NF component;
								</para>
							</listitem>
							<listitem>
								<para>
									<literal>setControllerObject(string itf, any controller class)</literal>:
									sets or replaces an existing controller object inside the
									membrane. Itf specifies the name of the control interface
									which has to be implemented by the controller class, given
									as second parameter. Replacing a controller object at runtime
									provides a very basic adaptivity of the membrane;
								</para>
							</listitem>
							<listitem>
								<para>
									<literal>startMembrane()</literal>: starts the membrane, i.e.
									allows NF calls on the host component to be served. This
									method has a recursive behavior, by starting the life-cycle
									of each NF component inside the membrane;
								</para>
							</listitem>
							<listitem>
								<para>
									<literal>stopMembrane()</literal>: Stops the membrane, i.e.
									prevents NF calls on the host component from being served
									except the ones on the membrane controller. This method has
									a recursive behavior, by stopping the life-cycle of each NF
									component.
								</para>
							</listitem>
						</itemizedlist>
					</para>

				</section>

				<section xml:id="Higher_level_API"><info><title>High level API</title></info>

					<figure xml:id="codeAPI2"><info><title>Higher level API</title></info>
						<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_17.snip"/></textobject></programlisting>
					</figure>

					<para>
						In <xref linkend="codeAPI2"/>, we present an alternative API, that
						addresses NF components by their names instead of their references. These
						methods allow to make calls on the binding controller and on the
						life-cycle controller of NF components that are hosted by the component
						membrane. Currently, they do not take into account the hierarchical aspect
						of NF components. The method calls address the NF components and call
						their controllers at once. For example, here is the Java code that binds
						two components inside the membrane using the general purpose API. It binds
						the interface “i1” of the component “nfComp1” inside the membrane to the
						interface “i2” of the component “nfComp2”. Suppose "mc" is a reference to
						the membrane controller of the host component.
						<programlisting language="java">Component nfComp1=mc.nfGetFcSubComponent("nfComp1");
Component nfComp2=mc.nfGetFcSubComponent("nfComp2");
GCM.getBindingController(nfComp1).bindFc("i1",nfComp2.getFcInterface("i2"));</programlisting>
					</para>

					<para>
						Using the API of <xref linkend="codeAPI2"/>, this binding can be realized
						by the following code, that binds the component “nfComp1” correctly.
						<programlisting language="java">mc.nfBindFc("nfComp1.i1","nfComp2.i2");</programlisting>
						Similarly to the example above, all the methods of
						<xref linkend="codeAPI2"/> result in calls on well-known Fractal controllers.
						Interfaces are represented as strings of the form component.interface, where
						component is the name of the inner component and interface is the name of
						its client or server interface. We use the name “membrane” to represent the
						membrane of the host component, e.g. membrane.i1 is the NF interface i1 of
						the host component. For example, <literal>nfBindFc(string, string)</literal>
						allows to perform the bindings: <emphasis>b1</emphasis>,
						<emphasis>b2</emphasis>, <emphasis>b4</emphasis>, <emphasis>b3</emphasis>,
						<emphasis>b9</emphasis>, <emphasis>b7</emphasis> and <emphasis>b5</emphasis>
						of <xref linkend="figStructure"/>.
					</para>

					<para>
						The API presented in <xref linkend="codeAPI2"/> introduced higher level
						mechanisms for reconfiguring the membrane. It also solves the problem of local
						components inside the membrane. As usual in distributed programming paradigms,
						GCM objects/components can be accessed locally or remotely. Remote references
						are accessible everywhere, while local references are accessible only in a
						restricted address space. When returning a local object/component outside its
						address space, there are two alternatives: create a remote reference on this
						entity; or make a copy of it. When considering a copy of a NF local component,
						the NF calls are not consistent. If an invocation on
						<literal>nfGetFcSubComponent(string name)</literal> returns a copy of the
						specified NF component, calls performed on this copy will not be performed
						on the “real” NF component inside the membrane. Methods introduced in
						<xref linkend="codeAPI2"/> solve this problem.
					</para>

				 </section>

			</section>

		</section>

		<section xml:id="Shortcuts_53"><info><title>Short cuts</title></info>

			<section xml:id="Principles_53"><info><title>Principles</title></info>

				<para>
					Communications between components in a hierarchical
					model may involve the crossing of several membranes,
					and therefore paying the cost of several
					indirections. If the invocations are not intercepted
					in the membranes, then it is possible to optimize
					the communication path by shortcutting:
					communicating directly from a caller component to a
					callee component by avoiding indirections in the
					membranes.
				</para>

				<para>
					In the Julia implementation, a shortcut mechanism is
					provided for components in the same JVM, and the
					implementation of this mechanism relies on code
					generation techniques.
				</para>

				<para>
					We provide a shortcut mechanism for distributed
					components, and the implementation of this mechanism
					relies on a "tensioning" technique: the first
					invocation determines the shortcut path, then the
					following invocations will use this shortcut path.
				</para>

				<para>
					For example, in the following figure, a simple
					component system, which consists of a composite
					containing two wrapped primitive components, is
					represented with different distributions of the
					components. In <emphasis role="bold">a</emphasis>,
					all components are located in the same JVM, therefore
					all communications are local communications. If the
					wrapping composites are distributed on different
					remote JVMs, all communications are remote because
					they have to cross composite enclosing components.
					The short cut optimization is a simple bypassing of
					the wrapper components, which results in 2 local
					communications for the sole functional interface.
				</para>

				<figure condition="html" xml:id="shortcuts_for_minimizing_remote_communication_html"><info><title>Using shortcuts for minimizing remote communications</title></info>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/shortcuts.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>

				<figure condition="pdf" xml:id="shortcuts_for_minimizing_remote_communication_pdf"><info><title>Using shortcuts for minimizing remote communications</title></info>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="700%" contentdepth="700%" fileref="images/png/shortcuts.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>

			</section>

			<section xml:id="Configuration_53"><info><title>Configuration</title></info>

				<para>
					Shortcuts are available when composite components
					are synchronous components (this does not break the
					ProActive model, as composite components are
					structural components). Components can be specified
					as synchronous in the ControllerDescription object
					that is passed to the component factory:
				</para>

				<programlisting language="java">ControllerDescription controllerDescription = new ControllerDescription("name", Constants.COMPOSITE, Constants.SYNCHRONOUS);</programlisting>

				<para>
					When the system property
					<emphasis role="bold">proactive.components.use_shortcuts</emphasis>
					is set to true, the component system will automatically
					establish short cuts between components whenever possible.
				</para>

			</section>

		</section>

		<section xml:id="configuration_html_interceptors_n"><info><title>Interceptors</title></info>

			<para>
				This section explains how to create and use interceptors.
			</para>

			<section xml:id="Configurationofinterceptors_53"><info><title>Configuration of interceptors</title></info>

				<para>
					Controllers and non functional components can also
					act as interceptors: they can intercept incoming
					invocations and/or outgoing invocations. To do so,
					controllers must implement the
					<literal>Interceptor</literal> interface and non
					functional components must provide a functional
					server interface implementing the
					<literal>Interceptor</literal> interface. For each
					invocation, pre and post processings are defined in
					the methods <literal>beforeMethodInvocation</literal>
					and <literal>afterMethodInvocation</literal>. These
					methods are defined in the
					<literal>Interceptor</literal> interface and take the
					name of the interface on which the interception has
					been made and a <literal>MethodCall</literal> object
					as arguments. <literal>MethodCall</literal> objects
					are reified representations of method invocations
					and they contain <literal>Method</literal> objects as
					well as the parameters of the invocation. The
					<literal>afterMethodInvocation</literal> method also
					takes as argument the return value of the method
					invocation. If the method returns
					<literal>void</literal>, then <literal>null</literal>
					is given as parameter. If the method returns a
					primitive type, then it is wrapped inside the
					appropriate wrapper object.
				</para>

				<para>
					Interceptors are configured with the interceptor
					controller. This controller is not included in the
					default controllers configuration so it must be
					explicitely added:
				</para>

				<programlisting language="xml"><textobject><textdata fileref="automatic_snippets/component_userguide_13.snip"/></textobject></programlisting>

				<para>
					The management of the interceptors is then done
					through the methods of the interceptor controller:
				</para>

				<programlisting language="xml"><textobject><textdata fileref="automatic_snippets/component_userguide_15.snip"/></textobject></programlisting>

				<para>
					Most of these methods take as parameter, among others,
					an <literal>interceptorID</literal>. This identifier
					may be:
				</para>

				<itemizedlist>
					<listitem>
						<para>
							The controller interface name of a controller
							that implements the <literal>Interceptor</literal>
							interface. For instance:
							<literal>myinterceptor-controller</literal>
						</para>
					</listitem>
					<listitem>
						<para>
							Or the concatenation of the name of a non
							functional component and the name of one
							of its server interfaces, that implements
							the <literal>Interceptor</literal>
							interface, separated by a point. For instance:
							<literal>InterceptorNFComponent.interceptor-services</literal>
						</para>
					</listitem>
				</itemizedlist>

				<para>
					Interceptors can also be attached to interfaces
					throught ADL. To do so, an additional attribute
					must be used in the <literal>interface</literal>
					tag of the interface on which to attach the
					interceptor(s). This attribute is
					<literal>interceptors</literal> and takes as
					value the list of interceptor identifiers that
					must act as interceptors for this interface.
					If the interceptor identifier represents a
					controller interface, the identifier must be
					prefixed by the "this." keyword like for
					bindings. If the interceptor identifier
					represents a server interface of a non
					functional component, the identifier is the
					same than the one used for the interceptor
					controller API (ie. the concatenation of the
					name of the non functional component and the
					name of its server interface). Each interceptor
					identifiers must be separated by a comma. When
					using this attribute, it becomes useless to
					explicitely add the interceptor controller to
					the list of controllers because it will be
					automatically added if it is not present by default.
				</para>

				<para>Interceptors can be composed in a sequentially manner.</para>

				<para>
					The <literal>beforeMethodInvocation</literal>
					method is called sequentially for each controller
					in the order they have been set with the interceptor
					controller or through ADL.
					The <literal>afterMethodInvocation</literal> method
					is called sequentially for each controller in the
					reverse order they have been set with the interceptor
					controller or through ADL.
				</para>

				<para>
					For instance, if 2 interceptors are attached to an interface
					in this order:
				</para>

				<screen>Interceptor1 and then Interceptor2</screen>

				<para>
					This means that an invocation on the interface will follow
					this path:
				</para>

				<programlisting language="java">&mdash;&gt; caller &mdash;&gt; Interceptor1.beforeMethodInvocation &mdash;&gt; Interceptor2.beforeMethodInvocation &mdash;&gt; callee.invocation &mdash;&gt; Interceptor2.afterMethodInvocation &mdash;&gt; Interceptor1.afterMethodInvocation</programlisting>

			</section>

			<section xml:id="Writingacustominterceptor_53"><info><title>Writing a custom interceptor</title></info>

				<para>
					To implement an interceptor as a controller object,
					it has to follow the rules explained in
					<xref linkend="configuration_html_controllers_n"/>
					for the
					creation of a custom controller. In addition of that,
					the controller object has to implement the
					<literal>Interceptor</literal> interface, which declares
					interception methods (pre/post interception) that have
					to be implemented.
				</para>

				<para>
					Here is a simple example of a controller object acting as
					an interceptor:
				</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/component_userguide_14.snip"/></textobject></programlisting>

				<para>
					Then for instance such an interceptor could be attached
					to an interface named "itf" by simply calling the
					<literal>addInterceptorOnInterface</literal> method
					of the interceptor controller:
				</para>

				<programlisting language="java">Utils.getPAInterceptorController(component).addInterceptorOnInterface("itf", "myinterceptor-controller");</programlisting>

				<para>
					By using ADL, the interceptor could be attached to
					the interface like that:
				</para>

				<programlisting language="xml">&lt;interface signature="signature-itf" role="server" name="itf" interceptors="this.myinterceptor-controller"/&gt;</programlisting>

				<para>
					To implement an interceptor as a non functional component,
					it has to follow the rules in explained in
					<xref linkend="Structuringthemembranewithnonfunctionalcomponents_53"/>
					for the creation of a non functional component. In addition
					of that, the non functional component has to provide a
					functional server interface that implements the
					<literal>Interceptor</literal> interface, which declares
					interception methods (pre/post interception) that have
					to be implemented.
				</para>

				<para>
					Here is a simple example of the ADL definition of a non
					functional component acting as an interceptor:
				</para>

				<programlisting language="xml"><textobject><textdata fileref="automatic_snippets/component_userguide_18.snip"/></textobject></programlisting>

				<para>
					Assuming this non functional component is named
					<literal>InterceptorNFComponent</literal>, then for
					instance such an interceptor could be attached
					to an interface named "itf" by simply calling the
					<literal>addInterceptorOnInterface</literal> method
					of the interceptor controller:
				</para>

				<programlisting language="java">Utils.getPAInterceptorController(component).addInterceptorOnInterface("itf", "InterceptorNFComponent.interceptor-services");</programlisting>

				<para>
					By using ADL, the interceptor could be attached to
					the interface like that:
				</para>

				<programlisting language="xml">&lt;interface signature="signature-itf" role="server" name="itf" interceptors="InterceptorNFComponent.interceptor-services"/&gt;</programlisting>

			</section>

		</section>

	</section>

</chapter>
